% \VignetteIndexEntry{Introduction to circlize package}
% \VignetteDepends{circlize}
% \VignetteKeywords{circos R}
% \VignetteKeywords{ideogram}
% \VignetteKeywords{circlize}
% \VignettePackage{circlize}

\documentclass{article}

\title{An introduction to {\tt circlize} package}

\author{Zuguang Gu {\tt <z.gu@dkfz.de>}\\ German Cancer Research Center,\\ Heidelberg, Germany}

\usepackage{Sweave}
\usepackage{hyperref}

\begin{document}

\maketitle 

\section{Introduction}
Circos layout (\url{http://circos.ca}) is very useful to represent complicated informations, especially for genomic data.
It is not only a way to visualize data, but also enhances the representation of scientific results into a level of aesthetics.
The {\tt circlize} package implements the circos layout in R. The advantage is that R is natural born to draw statistical
graphs, thus, types of plottings are not restricted by the package but by user's inspiration. The {\tt circlize} package allocates
and illustrates data which is from a certain category into a cell inside a circle and makes you
felling that you are plotting figures in a normal plotting coordinate.

Since most of the figures are composed of simple graphs, such as points, lines, polygon (for filled color) {\it et al},
so we just need to implement those low-level functions for drawing figures in circos layout.

Currently there are following functions that can be used for plotting, they are similar to the functions without {\tt "circos."}
prefix from the traditional graph engine:

\begin{itemize}
  \item {\tt circos.points}: draw points in a cell, similar as {\tt points}.
  \item {\tt circos.lines}: draw lines in a cell, similar as {\tt lines}.
  \item {\tt circos.rect}: draw rectangle in a cell, similar as {\tt rect}.
  \item {\tt circos.polygon}: draw polygon in a cell, similar as {\tt polygon}.
  \item {\tt circos.text}: draw text in a cell, similar as {\tt text}.
  \item {\tt circos.axis}: draw axis in a cell, functionally similar as {\tt axis} but with more features.
  \item {\tt circos.link}: this maybe the unique feature for circos layout to represent relationships between elements.
\end{itemize}

For drawing points, lines and text in cells through the whole track (among several sectors), the following functions are available:

\begin{itemize}
  \item {\tt circos.trackPoints}: this can be replaced by {\tt circos.points} through a {\tt for} loop.
  \item {\tt circos.trackLines}: this can be replaced by {\tt circos.lines} through a {\tt for} loop.
  \item {\tt circos.trackText}: this can be replaced by {\tt circos.text} through a {\tt for} loop.
\end{itemize}

Also, the function drawing histograms in the whole track is available:

\begin{itemize}
  \item {\tt circos.trackHist}
\end{itemize}

Functions to arrange the circos layout:

\begin{itemize}
  \item {\tt circos.trackPlotRegion}: create plotting regions of cells in one track
  \item {\tt circos.updatPlotRegion}: update one specified cell
  \item {\tt circos.par}: circos parameters
  \item {\tt circos.clear}: reset circos parameters and internal variables
\end{itemize}

Theoretically, you are able to draw most kinds of circos figures by the above functions. 
As you can see, all figures in the four vignettes are generated by {\tt circlize} package.

The following part of this vignette is structured as follows: First there is an example
to give a quick glance of how to draw a circos layout. Then it tells you the basic principle
(or the order of using the circos functions) for drawing. After that there are detailed explainations
of circos parameters, coordinates and low-level functions. Finally it would tell you some tricks
for drawing more complicated circos plot.

\section{A quick glance}
Following is an example. First generate some data. There needs to have a factor to represent categories,
values on x-axis, and values on y-axis.

<<label=figexample1, echo=TRUE, eval=FALSE>>=
set.seed(12345)
n = 10000
a = data.frame(factor = sample(letters[1:8], n, replace = TRUE),
    x = rnorm(n), y = runif(n))
@

Initialize the layout. In this step, the {\tt circos.initialize} function allocates sectors along
the circle according to ranges of x-values in different categories. E.g,
if there are two categories, range for x-values in the first category is {\tt c(0, 2)}
and range for x-values in the second category is {\tt c(0, 1)}, the first category
would hold approximately $67\%$ areas of the circle.
Here we only need x-values because all cells in a sector share the same
x-ranges.

<<label=figexample2, echo=TRUE, eval=FALSE>>=
library(circlize)
par(mar = c(1, 1, 1, 1), lwd = 0.1, cex = 0.7)
circos.par("default.track.height" = 0.1)
circos.initialize(factors = a$factor, x = a$x)
@

Draw the first track. Before drawing any track we need to know that all tracks should firstly be created by {\tt circos.trackPlotRegion}, then
those low-level functions can be applied. X-lims for cells in the track have already been defined in the initialization step, 
so here we only need to specify the y-lims for each cell, either by {\tt y}
or {\tt ylim} argument. 

We also draw axis for each cell in the first track, The axis for each cell is drawn by {\tt panel.fun} argument. 
{\tt circos.trackPlotRegion} creates plotting region cell by cell and the {\tt panel.fun}
is actually executed after the creation of the plotting region for the cell immediately. So {\tt panel.fun} actually means
drawing graphs in the ``current cell''. After that, draw points
through the whole track by {\tt circos.trackPoints}. Finally, add two texts in a certain cell
(the cell is specified by {\tt sector.index} and {\tt track.index} argument). In drawing the second
text, we do not specify {\tt track.index} because the package knows we are now in the first track.

Here what should be noted is that the first track has a index number of 1.
Then an internal variable which traces the tracks would set the current track index to 1. So if the track
index is not specified in the plotting functions such as {\tt circos.trackPoints} and {\tt circos.text}
which are called after the creation of the track, the current track index would be assigned internally.
So if {\tt track.index} is not specifed, it would use the current track index (it would be explained
in the following sections).

<<label=figexample3, echo=TRUE, eval=FALSE>>=
circos.trackPlotRegion(factors = a$factor, y = a$y,
    panel.fun = function(x, y) {
        circos.axis()
})
col = rep(c("#FF000010", "#00FF0010"), 4)
circos.trackPoints(a$factor, a$x, a$y, col = col,
    pch = 16, cex = 0.5)
circos.text(-1, 0.5, "left", sector.index = "a", track.index = 1)
circos.text(1, 0.5, "right", sector.index = "a")
@

Draw the second track. It is histograms among the track. The {\tt circos.trackHist}
can also create a new track because drawing histogram is really high-level. The track index for this track is 2.

<<label=figexample4, echo=TRUE, eval=FALSE>>=
bgcol = rep(c("#EFEFEF", "#CCCCCC"), 4)
circos.trackHist(a$factor, a$x, bg.col = bgcol, col = NA)
@

Draw the third track. Different background colors for cells can be assigned. So it may highlight some
feature of the {\tt circlize} package. Here some meta data for a cell can be obtained by {\tt get.cell.meta.data}. This function needs
{\tt sector.index} and {\tt track.index} arguments, and if they are not specified, it means
it is the current sector index and the current track index.

<<label=figexample5, echo=TRUE, eval=FALSE>>=
circos.trackPlotRegion(factors = a$factor, x = a$x, y = a$y,
  panel.fun = function(x, y) {
      grey = c("#FFFFFF", "#CCCCCC", "#999999")
      i = get.cell.meta.data("sector.numeric.index")
      circos.updatePlotRegion(bg.col = grey[i %% 3 + 1])
      circos.points(x[1:10], y[1:10], col = "red", pch = 16, cex = 0.6)
      circos.points(x[11:20], y[11:20], col = "blue", cex = 0.6)
  })
@

You can update an existed cell by specifying {\tt sector.index} and {\tt track.index} in {\tt circos.updatePlotRegion}.
The function erases graphs which have been drawn. Here we erase graphs in one cell in track 2, sector d
and re-draw some points. However, {\tt circos.updatePlotRegion} can not modify the {\tt xlim}
and {\tt ylim} of the cell as well as other settings related to the position of the cell.

<<label=figexample6, echo=TRUE, eval=FALSE>>=
circos.updatePlotRegion(sector.index = "d", track.index = 2)
circos.points(x = runif(100), y = runif(100))
@}

Draw the fouth track. Here you can choose different line types.

<<label=figexample7, echo=TRUE, eval=FALSE>>=
circos.trackPlotRegion(factors = a$factor, y = a$y)
circos.trackLines(a$factor[1:100], a$x[1:100], a$y[1:100], type = "h")
@

Draw links. Links can be from point to point, point to interval or interval to interval.
Some of the arguments would be explained in the following sections.

<<label=figexample8, echo=TRUE, eval=FALSE>>=
circos.link("a", 0, "b", 0, top.ratio = 0.9)
circos.link("c", c(-0.5, 0.5), "d", c(-0.5,0.5), col = "red",
    border = "blue", top.ratio = 0.2)
circos.link("e", 0, "g", c(-1,1), col = "green", lwd = 2, lty = 2)
circos.clear()
@

\begin{figure}
\begin{center}
<<label=figexample, fig = TRUE, echo = FALSE>>=
<<figexample1>>
<<figexample2>>
<<figexample3>>
<<figexample4>>
<<figexample5>>
<<figexample6>>
<<figexample7>>
<<figexample8>>
@
\end{center}
\caption{An example for circos layout}
\label{fig:example}
\end{figure}

The final figure looks like figure \ref{fig:example}.

<<label=figtransformation, echo=FALSE, eval=FALSE>>=
library(circlize)
layout(cbind(c(1, 0, 2, 0, 3)), height = c(2,0.5,2, 0.5, 4))
par(mar = c(2, 2, 2, 2))
x = 1:10
y = rnorm(10)
plot(x, y, type = "l", axes = FALSE, ann = FALSE)
text(2, 0, "text", cex = 2)
rect(5, -1, 7, 1)
box()
axis(side = 1)

par(mar = c(1, 1, 1, 1))
factors = letters[1:3]
circos.par("canvas.xlim" = c(-sqrt(3)/2, sqrt(3)/2), "canvas.ylim" = c(1/2*0.6, 1), start.degree = 30, "track.margin" = c(0, 0), "gap.degree" = 0, "clock.wise" = FALSE, points.overflow.warning = FALSE)
circos.initialize(factors = factors, xlim = c(1, 10))
circos.trackPlotRegion(factors = factors, ylim = range(y), track.height = 0.4, bg.border = NA)
circos.updatePlotRegion(sector.index = "a", track.index = 1, bg.border = "black")
circos.lines(x, y, sector.index = "a", track.index = 1, straight = TRUE)
circos.text(2, 0, "text", cex = 2)
circos.rect(5, -1, 7, 1)
circos.axis(h = "bottom")
circos.clear()

par(xpd = NA)
arrows(0, 1.33, 0, 1.07, code = 2)

par(mar = c(3, 3, 3, 3))
factors = letters[1:3]
circos.initialize(factors = factors, xlim = c(1, 10))
circos.trackPlotRegion(factors = factors, ylim = range(y), track.height = 0.4)
circos.updatePlotRegion(sector.index = "c", track.index = 1, bg.border = "black")
circos.lines(x, y, sector.index = "c", track.index = 1, straight = TRUE)
circos.text(2, 0, "text", cex = 2)
circos.rect(5, -1, 7, 1)
circos.axis(h = "bottom")
circos.clear()
box()
axis(side = 1)
axis(side = 2)
arrows(0, 1.5, 0, 1.07, code = 2)
@

\begin{figure}
\begin{center}
<<label=figtransformation, fig = TRUE, echo = FALSE, height=8.5, width=3.9>>=
<<figtransformation>>
@
\end{center}
\caption{Transformation between different coordinates. Top: data coordinate; Middle: polar coordinate; Bottom: canvas coordinate.}
\label{fig:transformation}
\end{figure}

\section{Details}
In this section, more details of the package would be explained.

\subsection{Rules to draw the circos layout}
The rules for drawing the circos layout is rather simple. It follows the sequence of
``initialize - create track - draw graphs - create track - draw graphs - ... - clear''.
See following:

\begin{enumerate}
  \item Initialize the layout using {\tt circos.initialize}. Since circos layout in fact visualizes data which is in categories,
        there should be a factor and a x-range to allocate categories into sectors.
  \item Create plotting regions for the new track and apply plottings. The new track is created just inside
        the previously created one and the index of the track is added by 1 automatically. Only after the creation of the track can you
        add other graphs on it. There are three ways to do the plotting job.
        \begin{enumerate}
            \item After the creation of the track. use low-level function like {\tt circos.points},
                  {\tt circos.lines}, ... to draw graphs cell by cell. It allways involves
                  a {\tt for} loop.
            \item Use {\tt circis.trackPoints}, {\tt circos.trackLines}, ... to draw same style
                  of graphs through all cells simultaneously. However, it is not recommended because
                  it would make you a little confused.
            \item Use {\tt panel.fun} argument in {\tt circos.trackPlotRegion} to draw
                  graphs immediately after the creation of certain cell. {\tt panel.fun} needs
                  two arguments {\tt x} and {\tt y} which are x-values and y-values that
                  in the current category. This subset operation would be applied internally.
        \end{enumerate}
        Plotting regions for cells that have been created can be updated by {\tt circos.updatePlotRegion}.
        {\tt circos.updatePlotRegion} will erase every that you have already plotted in the plotting region of the cell.
        
        Low level functions such as {\tt circos.points} can be applied on any created cell by specifying
        {\tt sector.index} and {\tt track.index}.
  \item Call {\tt circos.clear} to do cleanings.
\end{enumerate}

Codes for the circos layout drawing rule would looks like (pseudo code):
\begin{Schunk}
\begin{Sinput}
> circos.initialize(factors, xlim)
> circos.trackPlotRegion(factors, ylim)
> for(sector.index in all.sector.index) {
+     circos.points(x1, y1, sector.index)
+     circos.lines(x2, y2, sector.index)
+ }
\end{Sinput}
\end{Schunk}

or like following:
\begin{Schunk}
\begin{Sinput}
> circos.trackPlotRegion(factors, ylim)
> circos.trackPoints(factors, x1, y1)
> circos.trackLines(factors, x2, y2)
\end{Sinput}
\end{Schunk}

or like following. This the most natural way I feel.
\begin{Schunk}
\begin{Sinput}
> circos.trackPlotRegion(factors, x, y, ylim,
+   panel.fun = function(x, y) {
+     circos.points(x, y)
+     circos.lines(x, y)
+ })
\end{Sinput}
\end{Schunk}

There is several internal variables keeping tracing of the current sector and track when applying {\tt circos.trackPlotRegion} and {\tt circos.updatePlotRegion}.
So although functions like {\tt circos.points}, {\tt circos.lines} need to specify the index for sector and track,
the tracing values for sector index and the track index, by default, are taken as the current calculated ones. As a result,
if you draw points, lines, text, {\it et al} just after the creation of the track or cell, you do not need to set the sector
index and the track index explicitly and it is just drawn in the most nearly created cell. Note again, only {\tt circos.trackPlotRegion}
and {\tt corcos.updatePlotRegion} would reset the current track index and sector index.

Finally, in {\tt circlize} package, function with prefix {\tt circos.track} would affect all cells in a track.

\subsection{Coordinate transformation}
There is a data coordinate in which the range for x-axis and y-axis is the range of data,
a polar coordinate to allocates different cells on a circle and a the canvas coordinate which really
draws the figures (figure \ref{fig:transformation}). The package would first transform the data
coordinate to a polar coordinate and finally transform into the canvas coordinate.

The finnal canvas coordinate is in fact an ordinary coordinate in R plotting system with
x-range from -1 to 1 and y-range from -1 to 1 by defaulte.

{\it {\bf It should be noted that the circos layout is allways (or mostly if you want to draw something out of the plotting region) drawn inside the circle which has radius of 1 (unit
circle), from outside to inside. } }

However, for users, they only need to imagine that each cell is a normal rectangular plotting region (data coordinate) in
which x-lim and y-lim are ranges of data in that category respectively. The {\tt circlize} package would
know which cell you are drawing in and does the transformation.

<<label=figcoordinate, echo=FALSE, eval=FALSE>>=
library(circlize)
par(mar = c(1, 1, 1, 1))
factors = factor(letters[1:10], levels = sample(letters[1:10], 10))
circos.par("cell.padding" = c(0, 0, 0, 0), points.overflow.warning = FALSE)
circos.initialize(factors = factors, xlim = c(0, 10))
circos.trackPlotRegion(factors = factors, ylim = c(0, 10))
circos.trackPlotRegion(factors = factors, ylim = c(0, 10))
circos.trackPlotRegion(factors = factors, ylim = c(0, 10))
circos.trackPlotRegion(factors = factors, ylim = c(0, 10))
for(l in letters[1:10]) {
    circos.rect(0,0,10,10,sector.index = l, track.index = 2, col = "#FF000040")
}

for(l in 1:4) {
    circos.rect(0,0,10,10,sector.index = "a", track.index = l, col = "#0000FF40")
}
show.index()
circos.clear()

@

\begin{figure}
\begin{center}
<<label=figcoordinate, fig = TRUE, echo = FALSE>>=
<<figcoordinate>>
@
\end{center}
\caption{Coordinate in circos layout}
\label{fig:coordinate}
\end{figure}


\subsection{Sectors and tracks}

A circos layout is composed of sectors and tracks, as illustrated in figure \ref{fig:coordinate}.
The red circle is the track and the blue one is the sector. The intersection of a sector and 
a track is called a cell which can be thought as an imaginary plotting region for values in a certain category (data coordinate). 

Sectors are first allocated and determined by {\tt circos.initialize} and track allocation is then determined by {\tt circos.trackPlotRegion}.
{\tt circos.initialize} needs a category variable and data value which implicates the range of data in each category. The range
of data can be specified either by {\tt x} or {\tt xlim}.

\begin{Schunk}
\begin{Sinput}
> circos.initialize(factors, x)
> circos.initialize(factors, xlim)
\end{Sinput}
\end{Schunk}

There are something very important that should be noted in the initialization step. In this step, not only the width
of each sector is assigned, but also the order of each sector on the circle would be determined. 
{\bf Order of the sectors are determined by the order of levels of the factor}. So if you want to change the order
of the sectors, just change of the level of the {\tt factors} variable. If {\tt x} which is the x-value corresponding
to {\tt factors} is specified, the range for x-value in different category would be calculated according to {\tt factors}
automatically. And if {\tt xlim} is specified, it should be either a matrix which has same number of rows as the length
of the level of {\tt factors} or a two-element vector. If it is a two-element vector, it would be extended to a matrix which 
has the same number of rows as the length of {\tt factors} levels. Here, every row in {\tt xlim} corresponds to the x-ranges
of a category and the order of rows in {\tt xlim} corresponds to the order of levels of {\tt factors}.

Since all cells in one sector in different tracks share the same x-ranges, for each track, we only need to specify the y-ranges
for cells. Similar as {\tt circos.initialize}, {\tt circos.trackPlotRegion} can also receive either {\tt y} or {\tt ylim} argument
to specify the range of y-values. There is also a {\tt force.ylim} argument to sepcify whether all cells in one track should
share the same y-ranges. {\tt force.ylim} is only used along with {\tt y}.

\begin{Schunk}
\begin{Sinput}
> circos.trackPlotRegion(factors, y)
> circos.trackPlotRegion(factors, ylim)
\end{Sinput}
\end{Schunk}

In track creataion step, since all the sectors are already allocated in the circle, if {\tt factors} argument is not set, 
{\tt circos.trackPlotRegion} would create plotting regions for all available sectors. Also, levels of {\tt factors} do not
need to be specified explicitly because the order of sectors has already be determined in the initialization step. If {\tt factors} is just a vector, it 
would be converted to factor automatically. And finally if users just create cells in part of sectors in the track (not all sectors), in fact, the cells in remaining
unspecified sectors would also be created, but with no borders (pretending they are not created).


<<label=figregion, echo=FALSE, eval=FALSE>>=
library(circlize)
par(mar = c(1, 1, 1, 1), "xaxs" = "i", "yaxs" = "i")
factors = letters[1:8]
circos.par("canvas.xlim" = c(0, 1), "canvas.ylim" = c(0, 1), "gap.degree" = 3, "start.degree" = 20, "track.margin" = c(0.05, 0.05), "clock.wise" = FALSE)
circos.initialize(factors = factors, xlim = c(0, 10))

circos.trackPlotRegion(factors = factors, ylim = c(0, 10), track.height = 0.1, bg.border = NA, bg.col = "#E41A1C", panel.fun = function(x, y) {
    xlim = get.cell.meta.data("xlim")
    ylim = get.cell.meta.data("ylim")
    cell.xlim = get.cell.meta.data("cell.xlim")
    cell.ylim = get.cell.meta.data("cell.ylim")
    circos.rect(xlim[1], ylim[1], xlim[2], ylim[2], col = "#377EB8", border = "black", lwd = 2)
    circos.rect(cell.xlim[1], cell.ylim[2], cell.xlim[2], cell.ylim[2]+(cell.ylim[2]-cell.ylim[1])/2, col = "#984EA3", border = NA)
    circos.rect(cell.xlim[1], cell.ylim[1]-(cell.ylim[2]-cell.ylim[1])/2, cell.xlim[2], cell.ylim[1], col = "#984EA3", border = NA)
    circos.lines(0:10, runif(11)*10)
    circos.rect(cell.xlim[1], cell.ylim[1], cell.xlim[2], cell.ylim[2], lwd = 2, lty = 2)
})
circos.trackPlotRegion(factors = factors, ylim = c(0, 10), track.height = 0.3, bg.border = NA, bg.col = "#E41A1C", panel.fun = function(x, y) {
    xlim = get.cell.meta.data("xlim")
    ylim = get.cell.meta.data("ylim")
    cell.xlim = get.cell.meta.data("cell.xlim")
    cell.ylim = get.cell.meta.data("cell.ylim")
    circos.rect(xlim[1], ylim[1], xlim[2], ylim[2], col = "#377EB8", border = "black", lwd = 2)
    circos.rect(cell.xlim[1], cell.ylim[2], cell.xlim[2], cell.ylim[2]+(cell.ylim[2]-cell.ylim[1])/6, col = "#984EA3", border = NA)
    circos.rect(cell.xlim[1], cell.ylim[1]-(cell.ylim[2]-cell.ylim[1])/6, cell.xlim[2], cell.ylim[1], col = "#984EA3", border = NA)
    circos.lines(0:10, runif(11)*10)
    circos.rect(cell.xlim[1], cell.ylim[1], cell.xlim[2], cell.ylim[2], lwd = 2, lty = 2)
})
circos.trackPlotRegion(factors = factors, ylim = c(0, 10), track.height = 0.1, bg.border = NA, bg.col = "#E41A1C", panel.fun = function(x, y) {
    xlim = get.cell.meta.data("xlim")
    ylim = get.cell.meta.data("ylim")
    cell.xlim = get.cell.meta.data("cell.xlim")
    cell.ylim = get.cell.meta.data("cell.ylim")
    circos.rect(xlim[1], ylim[1], xlim[2], ylim[2], col = "#377EB8", border = "black", lwd = 2)
    circos.rect(cell.xlim[1], cell.ylim[2], cell.xlim[2], cell.ylim[2]+(cell.ylim[2]-cell.ylim[1])/2, col = "#984EA3", border = NA)
    circos.rect(cell.xlim[1], cell.ylim[1]-(cell.ylim[2]-cell.ylim[1])/2, cell.xlim[2], cell.ylim[1], col = "#984EA3", border = NA)
    circos.lines(0:10, runif(11)*10)
    circos.rect(cell.xlim[1], cell.ylim[1], cell.xlim[2], cell.ylim[2], lwd = 2, lty = 2)
})

x = seq(0, 1, length = 1000)
y = sqrt(1^2 - x^2)
lines(x, y, lty = 3, lwd = 2)

x = seq(0, 0.8, length = 1000)
y = sqrt(0.8^2 - x^2)
lines(x, y, lty = 3, lwd = 2)

x = seq(0, 0.4, length = 1000)
y = sqrt(0.4^2 - x^2)
lines(x, y, lty = 3, lwd = 2)

x = seq(0, 0.2, length = 1000)
y = sqrt(0.2^2 - x^2)
lines(x, y, lty = 3, lwd = 2)

draw.sector(center = c(0, 0), start = 17, end = 20, rou1 = 1, rou2 = 0.2, col = "#4DAF4A")
draw.sector(center = c(0, 0), start = 62, end = 65, rou1 = 1, rou2 = 0.2, col = "#4DAF4A")

circos.text(5, 5, "plotting region", sector.index = "a", track.index = 2)
circos.text(5, 10.5, "cell.padding[3]", sector.index = "a", track.index = 2)
circos.text(5, -0.5, "cell.padding[1]", sector.index = "a", track.index = 2)
circos.text(-0.5, 5, "cell.padding[2]", direction = "vertical_right", sector.index = "a", track.index = 2)
circos.text(10.5, 5, "cell.padding[4]", direction = "vertical_right", sector.index = "a", track.index = 2)
circos.text(5, -2, "track.margin[1]", sector.index = "a", track.index = 2)
circos.text(5, 12, "track.margin[2]", sector.index = "a", track.index = 2)
circos.text(-1.5, 5, "gap.degree", direction = "vertical_right", sector.index = "a", track.index = 2)
circos.text(11.5, 5, "gap.degree", direction = "vertical_right", sector.index = "a", track.index = 2)
circos.clear()
@

\begin{figure}
\begin{center}
<<label=figregion, fig = TRUE, echo = FALSE>>=
<<figregion>>
@
\caption{Regions for a cell}
\label{fig:region}
\end{center}
\end{figure}

<<label=figdirection, echo=FALSE, eval=FALSE>>=
par(mfrow = c(2, 1))
par(mar = c(1, 1, 1, 1))
factors = letters[1:8]
circos.par("track.margin" = c(0.1, 0.1), "clock.wise" = FALSE, start.degree = 30)
circos.initialize(factors = factors, xlim = c(0, 10))
circos.trackPlotRegion(factors = factors, ylim = c(0, 10), track.height = 0.4, panel.fun = function(x, y) {
    circos.text(5, 5, get.cell.meta.data("sector.index"))
    xlim = get.cell.meta.data("xlim")
    ylim = get.cell.meta.data("ylim")
    circos.lines(xlim, c(0, 0))
    circos.lines(c(9, 10), c(0.5, 0))
    circos.lines(c(9, 10), c(-0.5, 0))
    circos.lines(c(0, 0), xlim)
    circos.lines(c(0.5, 0), c(9, 10))
    circos.lines(c(-0.5, 0), c(9, 10))
})
circos.clear()

x = seq(-0.7, 0.7, length = 100)
d = cbind(x, sqrt(1 - x^2))
lines(d)
arrows(d[2,1], d[2,2], d[1,1], d[1,2])

x = seq(-0.7, 0.7, length = 100)
d = cbind(x, -sqrt(1 - x^2))
lines(d)
arrows(d[99,1], d[99,2], d[100,1], d[100,2])

text(0, 0, 'circos.par("clock.wise" = FALSE,\nstart.degree = 30)', cex = 0.6)

par(mar = c(1, 1, 1, 1))
factors = letters[1:8]
circos.par("track.margin" = c(0.1, 0.1), "clock.wise" = TRUE, start.degree = -30)
circos.initialize(factors = factors, xlim = c(0, 10))
circos.trackPlotRegion(factors = factors, ylim = c(0, 10), track.height = 0.4, panel.fun = function(x, y) {
    circos.text(5, 5, get.cell.meta.data("sector.index"))
    xlim = get.cell.meta.data("xlim")
    ylim = get.cell.meta.data("ylim")
    circos.lines(xlim, c(0, 0))
    circos.lines(c(9, 10), c(0.5, 0))
    circos.lines(c(9, 10), c(-0.5, 0))
    circos.lines(c(0, 0), xlim)
    circos.lines(c(0.5, 0), c(9, 10))
    circos.lines(c(-0.5, 0), c(9, 10))
})
circos.clear()

x = seq(-0.7, 0.7, length = 100)
d = cbind(x, sqrt(1 - x^2))
lines(d)
arrows(d[99,1], d[99,2], d[100,1], d[100,2])


x = seq(-0.7, 0.7, length = 100)
d = cbind(x, -sqrt(1 - x^2))
lines(d)
arrows(d[2,1], d[2,2], d[1,1], d[1,2])
text(0, 0, 'circos.par("clock.wise" = TRUE,\nstart.degree = -30)', cex = 0.6)
@

\begin{figure}
\begin{center}
<<label=figdirection, fig = TRUE, echo = FALSE, width=4, height=8>>=
<<figdirection>>
@
\end{center}
\caption{Sector directions. Sector orders are {\tt a}, ..., {\tt h}.}
\label{fig:direction}
\end{figure}


\subsection{Circos parameters}
Some basic parameters for the circos layout can be set through {\tt circos.par}. The paramters
are as follows, note some parameters can only be assigned before the initialization of the circos layout.

\begin{itemize}
    \item {\tt start.degree}: The starting degree at which the circle begin to draw. Note this degree is measured 
          in the standard polar coordinate which means it is always reverse clockwise. See figure \ref{fig:direction}.
    \item {\tt gap.degree}: Gap between two neighbour sectors. See figure \ref{fig:region}.
    \item {\tt track.margin}: Like {\tt margin} in Cascading Style Sheets (CSS), it is the blank area
          out of the plotting region, also outside of the borders. Since left and right margin are controlled
          by {\tt gap.degree}, only bottom and top margin need to be set. The value for the {\tt track.margin}
          is the percentage according to the radius of the unit circle. See figure \ref{fig:region}.
    \item {\tt cell.padding}: Padding of the cell. Like {\tt padding} in Cascading Style Sheets
          (CSS), it is the blank area around the plotting regions, but within the borders.
          The paramter has four values, which controls the bottom, left, top and right padding
          respectively. The four values are all percentages in which the first and the third padding
          values are the percentages according to the range of values on y-axis and the second and
          fourth values are the percentages according to the range of values on x-axis. See figure \ref{fig:region}.
    \item {\tt unit.circle.segments}: Since curves are simulated by a series of straight lines,
          this parameter controls the amout of segments to represent a curve. The minimal length
          of the line segmentation is the length of the unit circle ({\tt 2*pi}) divided by {\tt unit.circle.segments}.     
    \item {\tt default.track.height}: The default height of tracks. It is the percentage according to the radius
          of the unit circle ({\tt 1}). The height includes the top and bottom cell paddings but not the margins.
    \item {\tt points.overflow.warning}: Since each cell is in fact not a real plotting region but only
          an ordinary rectangle, it does not eliminate points that are plotted out of
          the region. So if some points are out of the plotting region, by default, the 
          package would continue drawing the points and print warnings. But in some 
          circumstances, draw something out of the plotting region is useful, such as draw
          some legend or text. Set this value to {\tt FALSE} to turn off the warnings.
    \item {\tt canvas.xlim}: The coordinate for the canvas. By default, the package draws unit circle, so
          the {\tt xlim} and {\tt ylim} for the canvas would be {\tt c(-1, 1)}. However, you can set it to a more broad
          interval if you want to draw other things out of the circle. By choose proper
          {\tt canvas.xlim} and {\tt canvas.ylim}, you can draw part of the circle. E.g. setting
          {\tt canvas.xlim} to {\tt c(0, 1)} and {\tt canvas.ylim} to {\tt c(0, 1)} would only draw
          circle in the region of {\tt (0, pi/2)}.
    \item {\tt canvas.ylim}: The coordinate for the canvas.
    \item {\tt clock.wise}: The order of drawing sectors. Default is {\tt TRUE} which means reverse clockwise (figure \ref{fig:direction}).
          But note that inside each cell, the direction of x-axis is always reverse clockwise and direction of y-axis is always from inside to outside in the circle.
\end{itemize}

Parameters related to the allocation of sectors can be changes after the initialization of the layout.
So {\tt start.degree}, {\tt gap.degree}, {\tt canvas.xlim}, {\tt canvas.ylim} and {\tt clock.wise} can only
be modified before {\tt circos.initialize}. The second and the fourth element of {\tt cell.padding} (left and right paddings) can not
be modified either.

<<label=figlines, echo=FALSE, eval=FALSE>>=
library(circlize)
par(mar = c(1, 1, 1, 1), cex = 0.8)
factors = letters[1:8]
circos.par(points.overflow.warning = FALSE)
circos.initialize(factors = factors, xlim = c(0, 10))
circos.trackPlotRegion(factors = factors, ylim = c(0, 10), track.height = 0.5)
circos.lines(sort(runif(10)*10), runif(10)*8, sector.index = "a")
circos.text(5, 9, "type = 'l'", sector.index = "a")
circos.lines(sort(runif(10)*10), runif(10)*8, sector.index = "b", type = "o")
circos.text(5, 9, "type = 'o'", sector.index = "b")
circos.lines(sort(runif(10)*10), runif(10)*8, sector.index = "c", type = "h")
circos.text(5, 9, "type = 'h'", sector.index = "c")
circos.lines(sort(runif(10)*10), runif(10)*8, sector.index = "d", type = "s")
circos.text(5, 9, "type = 's'", sector.index = "d")
circos.lines(sort(runif(10)*10), runif(10)*8, sector.index = "e", area = TRUE)
circos.text(5, 9, "type = 'l', area = TRUE", sector.index = "e")
circos.lines(sort(runif(10)*10), runif(10)*8, sector.index = "f", type = "o", area = TRUE)
circos.text(5, 9, "type = 'o', area = TRUE", sector.index = "f")
circos.lines(sort(runif(10)*10), runif(10)*8, sector.index = "g", type = "s", area = TRUE)
circos.text(5, 9, "type = 's', area = TRUE", sector.index = "g")
circos.lines(sort(runif(10)*10), runif(10)*8, sector.index = "h", area = TRUE, area.baseline = "top")
circos.text(5, 1, "type = 'l', area = TRUE\narea.baseline = 'top'", sector.index = "h")
circos.clear()
par(cex = 1)
@

\begin{figure}
\begin{center}
<<label=figlines, fig = TRUE, echo = FALSE>>=
<<figlines>>
@
\end{center}
\caption{Line style settings}
\label{fig:lines}
\end{figure}

\subsection{Points}
Drawing points is similar as {\tt points} function.


\subsection{Lines}
Parameters for drawing lines by {\tt circos.lines} are similar to {\tt lines} function, 
as illustrated in figure \ref{fig:lines}. One additional feature is that the areas under/above lines can be 
specified by {\tt area} argument which can help you identifying the direction of y-axis. Also the base line for the area can be set by {\tt area.baseline}.
{\tt area.baseline} can be pre-defined string of {\tt bottom} or {\tt top}, or numeric values.

Straight lines will be transformed to curves when mapping to the circos layout. Normally, 
curves can be approximated by a series of segmentation of straight lines. With more segmentations,
there would be better approximations, but with larger size if you generate the graph as pdf format, especially
for huge genomic data. So, in this package, the number of the segmentation can be controlled by {\tt circos.par("unit.circle.segments")}.
The length of minimal segment is the length of the unit circle divided by 
{\tt circos.par("unit.circle.segments")}. If you do not want such curve-transformations (such as
radical lines), you can set {\tt straight} argument to {\tt TRUE}. 

<<label=figtext, echo=FALSE, eval=FALSE>>=
library(circlize)
par(mar = c(1, 1, 1, 1))
factors = letters[1:4]
circos.par(points.overflow.warning = FALSE)
circos.initialize(factors = factors, xlim = c(0, 10))
circos.trackPlotRegion(factors = factors, ylim = c(0, 10), track.height = 0.5, panel.fun = function(x, y) {
    circos.text(3, 9, "default", direction = "default")
    circos.text(7, 9, "default2", direction = "default2")
    circos.text(0, 5, "vertical_left", direction = "vertical_left")
    circos.text(10, 5, "vertical_right", direction = "vertical_right")
    circos.text(5, 5, "horizontal", direction = "horizontal")
    circos.text(5, 1, "arc_arc_arc_arc_arc", direction = "arc")
})
circos.clear()
@

\begin{figure}
\begin{center}
<<label=figtext, fig = TRUE, echo = FALSE>>=
<<figtext>>
@
\end{center}
\caption{Text direction settings}
\label{fig:text}
\end{figure}


\subsection{Text}
Only the direction of text by {\tt circos.text} should be noted, as illustrated in figure \ref{fig:text}.
Only six directions of text are allowed which are in {\tt c("default", "default2", "vertical\_left", "vertical\_right", "horizontal", "arc")}.

\begin{itemize}
    \item {\tt default}: direction of the tangent, facing bottom at $90^\circ$ position.
    \item {\tt default2}: direction of the tangent, facing bottom at $-90^\circ$ position.
    \item {\tt vertical\_left}: direction of radius, facing left at $90^\circ$ position.
    \item {\tt vertical\_left}: direction of radius, facing right at $90^\circ$ position.
    \item {\tt horizontal}: horizontal direction in the canvas coordinate.
    \item {\tt arc}: direction of the arc.
\end{itemize}

{\tt srt} in {\tt text} has been degenerated as {\tt direction} in {\tt circos.text} which only support only six rotation.
But {\tt adj} argument is still applicable in {\tt circos.text}.

<<label=figaxis, echo=FALSE, eval=FALSE>>=
library(circlize)

par(mar = c(1, 1, 1, 1))
factors = letters[1:8]
circos.par(points.overflow.warning = FALSE)
circos.initialize(factors = factors, xlim = c(0, 10))
circos.trackPlotRegion(factors = factors, ylim = c(0, 10), track.height = 0.1, bg.border = NA, panel.fun = function(x, y) {
    circos.text(5, 10, get.cell.meta.data("sector.index"))
})

circos.trackPlotRegion(factors = factors, ylim = c(0, 10))
circos.axis(sector.index = "a")
circos.axis(sector.index = "b", direction = "inside", labels.direction = "default2")
circos.axis(sector.index = "c", h = "bottom")
circos.axis(sector.index = "d", h = "bottom", direction = "inside")
circos.axis(sector.index = "e", h = 5, major.at = c(1, 3, 5, 7, 9))
circos.axis(sector.index = "f", h = 5, major.at = c(1, 3, 5, 7, 9), labels = c("a", "c", "e", "g", "f"), minor.ticks = 0)
circos.axis(sector.index = "g", h = 5, major.at = c(1, 3, 5, 7, 9), labels = c("a1", "c1", "e1", "g1", "f1"), major.tick = FALSE, labels.direction = "vertical_left")
circos.axis(sector.index = "h", h = 2, major.at = c(1, 3, 5, 7, 9), labels = c("a1", "c1", "e1", "g1", "f1"), major.tick.percentage = 0.3, labels.away.percentage = 0.2, minor.ticks = 2, labels.direction = "vertical_right")
circos.clear()
@

\begin{figure}
\begin{center}
<<label=figaxis, fig = TRUE, echo = FALSE>>=
<<figaxis>>
@
\end{center}
\caption{Axis settings}
\label{fig:axis}
\end{figure}

\subsection{Axis}
Because there may be no space to draw y-axis, only drawing x-axis for each cell is supported by {\tt circos.axis}, as illustrated in figure \ref{fig:axis}.
A lot of styles for axis can be set such as the position and length of major ticks, the number of minor ticks,
the position and direction of the axis labels and the position of the x-axis. Note the adjustment of label strings is defined internally according
to differnet label directions to ensure the start/end position of the string is located near the major tick.


<<label=figlink, echo=FALSE, eval=FALSE>>=
library(circlize)
par(mar = c(1, 1, 1, 1), mfrow = c(2, 1))
factors = letters[1:8]
circos.par(points.overflow.warning = FALSE)
circos.initialize(factors = factors, xlim = c(0, 10))
circos.trackPlotRegion(factors = factors, ylim = c(0, 1), bg.col = "grey", bg.border = NA, track.height = 0.05)

circos.link("a", 5, "c", 5)
circos.link("b", 5, "d", c(4, 6))
circos.link("a", c(2, 3), "f", c(4, 6))

circos.clear()


degree.minus = function(to, from, min.zero = TRUE) {
    if(min.zero) {
        return((to - from) %% 360)
    } else {
        if((to - from) %% 360 == 0) {
            return(360)
        } else {
            return((to - from) %% 360)
        }
    }
}
rotate.parabola = function(theta1, theta2, rou1, rou2 = rou1, theta = (theta1+theta2)/2, 
    rou = rou1 * abs(cos(degree.minus(theta1, theta2)/2/180*pi))*rou.ratio, rou.ratio = 0.5,
    n = 1001) {
    
    while(theta2 < theta1) {
        theta2 = theta2 + 360
    }
    
    delta_theta = degree.minus(theta2, theta1)
    
    flag = 0
    if(delta_theta > 180) {
        theta = theta + 180
        flag = 1
    }
    
    # y^2 = kx, y = +-sqrt(kx)
    b = rou1 * abs(sin(degree.minus(theta2, theta1)/2/180*pi))
    a = rou1 * abs(cos(degree.minus(theta2, theta1)/2/180*pi)) - rou
    k = b^2/a
    
    if(n %% 2 == 0) {
        n = n + 1
    }
    n.half = (n - 1) / 2
    x = numeric(n)
    y = numeric(n)
    x = c(n.half:1/n.half, 0, 1:n.half/n.half)*a
    y[1:n.half] = sqrt(k*x[1:n.half])
    y[n.half + 1] = 0
    y[1:n.half + n.half + 1] = -sqrt(k*x[1:n.half + n.half + 1])
    
    alpha = numeric(n)
    
    alpha[1:n.half] = atan(y[1:n.half]/x[1:n.half])*180/pi
    alpha[1:n.half + n.half + 1] = atan(y[1:n.half + n.half + 1]/x[1:n.half + n.half + 1])*180/pi
    alpha[n.half + 1] = 90
    
    d = sqrt(x^2 + y^2)
    x = d*cos((alpha + theta)/180*pi)
    y = d*sin((alpha + theta)/180*pi)
    
    center.x = rou*cos(theta/180*pi)
    center.y = rou*sin(theta/180*pi)
    
    x = x + center.x
    y = y + center.y
    
    if(!flag) {
        x = rev(x)
        y = rev(y)
    }

    return(cbind(x, y))
}

polar2Cartesian = function(d) {
    theta = d[, 1]/360 * 2 *pi
    rou = d[, 2]
    x = rou * cos(theta)
    y = rou * sin(theta)
    return(cbind(x, y))
}
par(mar = c(1, 1, 1, 1))
plot(c(-1, 1), c(-1, 1), axes = FALSE, ann = FALSE ,type = "n")
draw.sector(center = c(0, 0), start.degree = 0, end.degree = 360, rou1 = 1, col = "white", border = "black")
d= rotate.parabola(theta1 = 270, theta2 = 330, rou1 = 1, rou.ratio = 0.5)
lines(rbind(d, d[1, ]))
lines(c(cos(300/180*pi), cos(120/180*pi)), c(sin(300/180*pi), sin(120/180*pi)))
points(0, 0, pch = 16)
lines(c(0, sqrt(3)/4)+0.01, c(0, -3/4)+0.01, lwd = 4, col = "red")
lines(c(0, sqrt(3)/4/2)-0.01, c(0, -3/4/2)-0.01, lwd = 4, col = "blue")
@

\begin{figure}
\begin{center}
<<label=figlink, fig = TRUE, echo = FALSE, height=8, width=4>>=
<<figlink>>
@
\end{center}
\caption{Drawing links}
\label{fig:link}
\end{figure}


\subsection{Links}
Links can be drawn by {\tt circos.link} from points and intervals (figure \ref{fig:link}, top). If both ends are points, then the link is represented
as a line. If one of the ends is an interval, the link would be a belt. The link is in fact a quadratic curve. Links do not hold any position of track.

The position of the 'root' of the link is controlled by {\tt rou} argument. By default, it is the end position on the circle radius of the most recently created track.
So normally, you don't need to care about this setting.

The height of the link can be controlled by {\tt top.ratio} argument in {\tt circos.link} which is the ratio between the length of blue line and 
the red line (maximum of the link height), see figure \ref{fig:link}, bottom. The default height looks well from my view point, so you don't need to change this value.


\subsection{The {\tt panel.fun} argument in {\tt circos.trackPlotRegion}}
{\tt panel.fun} argument in {\tt circos.trackPlotRegion} is useful to apply plottings as soon as the cell has been created. This self-defined
function need two arguments {\tt x} and {\tt y} which are data points in the cell. The value for such values are automatically extracted from {\tt x} and {\tt y}
in {\tt circos.trackPlotRegion} function according to the category argument {\tt factors}. In the following example, {\tt x} in category {\tt a} in {\tt panel.fun}
would be {\tt 1:3} and {\tt y} values are {\tt 5:3}. If {\tt x} or {\tt y} in {\tt circos.trackPlotRegion} is {\tt NULL}, then {\tt x} or {\tt y} inside
{\tt panel.fun} is also {\tt NULL}.

In {\tt panel.fun}, one thing important is that if you use any low-level circos functions, you don't need to specify {\tt sector.index} and {\tt track.index} explicitly.
Remember that when applying {\tt circos.trackPlotRegion}, cells in the track are created one after one. When a cell is created, the package would set the sector index
and track index of the cell as the 'current' index for sector and track. When the cell is created, {\tt panel.fun} would be exceeded afterward immediately. Without specifying
{\tt sector.index} and {\tt track.index}, the default ones would be used.

Inside {\tt panel.fun}, more information of the 'current' cell would be obtained through
{\tt get.cell.meta.data}. Also this funciton takes the 'current' sector and 'current' track by default,
so that is just the cell which is just created. Explaination of {\tt get.cell.meta.data} can be found in
following section.

\begin{Schunk}
\begin{Sinput}
> factors = c("a", "a", "a", "b", "b")
> x = 1:5
> y = 5:1
> circos.trackPlotRegion(factors = factors, x = x, y = y,
+     panel.fun = function(x, y) {
+         circos.points(x, y)
+     })
\end{Sinput}
\end{Schunk}


\subsection{High level plotting functions}
With those low-level function such as {\tt circos.points}, {\tt circos.lines},
more high-level functions can be easily written. The package provides a high-level 
function {\tt circos.trackHist} which draws histograms or the density
distributions of data (figure \ref{fig:hist}). So users would know how to implement other
high-level function to support graphs such as barplot, heatmap, ... accroding to the source code of {\tt circos.trackHist}.

In figure \ref{fig:hist}, the first track is histograms in which all the {\tt ylim} are the same.
The second track is histograms in which {\tt force.ylim} is {\tt FALSE}.
The third and the fourth tracks are density distributions in which ylims
are forced same or different.


<<label=fighist, echo=FALSE, eval=FALSE>>=
library(circlize)
par(mar = c(1, 1, 1, 1))
x = rnorm(2600)
factors = sample(letters, 2600, replace = TRUE)
circos.initialize(factors = factors, x = x)
circos.trackHist(factors = factors, x = x, track.height = 0.1, col = "#CCCCCC", border = "#CCCCCC")
circos.trackHist(factors = factors, x = x, force.ylim = FALSE, track.height = 0.1, col = "#CCCCCC", border = "#CCCCCC")
circos.trackHist(factors = factors, x = x, draw.density = TRUE, track.height = 0.1, col = "#CCCCCC", border = "#CCCCCC")
circos.trackHist(factors = factors, x = x, draw.density = TRUE, force.ylim = FALSE, track.height = 0.1, col = "#CCCCCC", border = "#CCCCCC")

circos.clear()

@

\begin{figure}
\begin{center}
<<label=fighist, fig = TRUE, echo = FALSE>>=
<<fighist>>
@
\end{center}
\caption{Histograms}
\label{fig:hist}
\end{figure}

\subsection{Other functions}
{\tt draw.sector} can be used to draw sectors or part of a ring. This is useful if you want to hightlight some part of your circos plot.
As you can think, this function need arguments of the position of circle center, the start degree and the end degree for sectors, 
and radius for two edges (or one edge) of the arc which may be the up or bottom border of a cell. These information can be obtained by {\tt get.cell.meta.data}. E.g. the start degree
and end degree can be obtained through {\tt cell.start.degree} and {\tt cell.end.degree}, and the position of the top border and bottom
border on the circle radius can be obtained through {\tt cell.top.radius} and {\tt cell.bottom.radius}. An example is as follows and see figure \ref{fig:sectorhighlight}
in which different colors correspond to different regions that need to be highlighted.

{\tt get.cell.meta.cell} can provide detailed information for a cell:

\begin{itemize}
  \item {\tt sector.index}: The name (label) for the sector
  \item {\tt sector.numeric}.index: Numeric index for the sector
  \item {\tt track.index}: Numeric index for the track
  \item {\tt xlim}: Minimal and maximal values on the x-axis
  \item {\tt ylim}: Minimal and maximal values on the y-axis
  \item {\tt xrange}: Range of {\tt xlim}
  \item {\tt yrange}: Range of {\tt ylim}
  \item {\tt cell.xlim}: Minimal and maximal values on the x-axis extended by cell paddings
  \item {\tt cell.ylim}: Minimal and maximal values on the y-axis extended by cell paddings
  \item {\tt xplot}: Right and left border degree for the plotting region in the unit circle.
                        The first element corresponds to the start point of values on x-axis ({\tt cell.xlm[1]})
                        and the second element corresponds to the end point of values on x-axis ({\tt cell.xlim[2]})
                        Since x-axis in data coordinate in cells are always reverse clockwise, {\tt xplot[1]} is larger
                        than {\tt xplot[2]}.
  \item {\tt yplot}: Bottom and top radius value for borders of the plotting region. It is the value
                        of radius of arc corresponding to inner border or outer border.
  \item {\tt cell.start.degree}: Same as {\tt xplot[1]}
  \item {\tt cell.end.degree}: Same as {\tt xplot[2]}
  \item {\tt cell.bottom.radius}: Same as {\tt yplot[1]}
  \item {\tt cell.top.radius}: Same as {\tt yplot[2]}
  \item {\tt track.margin}: Margins for the cell
  \item {\tt cell.padding}: Paddings for the cell
\end{itemize}

<<label=sectorhighlight, echo=FALSE, eval=FALSE>>=
library(circlize)

factors = letters[1:8]

par(mar = c(1, 1, 1, 1))
circos.initialize(factors = factors, xlim = c(0, 1))
circos.trackPlotRegion(ylim = c(0, 1))
circos.trackPlotRegion(ylim = c(0, 1))
circos.trackPlotRegion(ylim = c(0, 1))

xplot.a1 = get.cell.meta.data("xplot", "a", 1)
yplot.a1 = get.cell.meta.data("yplot", "a", 1)
draw.sector(start.degree = xplot.a1[1], end.degree = xplot.a1[2], rou1 = yplot.a1[2], border = NA, col = "#FF000040")

xplot.b2 = get.cell.meta.data("xplot", "b", 2)
yplot.b2 = get.cell.meta.data("yplot", "b", 2)
draw.sector(start.degree = xplot.b2[1], end.degree = xplot.b2[2], rou1 = yplot.b2[2], border = NA, col = "#FF00FF40")

draw.sector(start.degree = 0, end.degree = 360, rou1 = yplot.a1[2], rou2 = yplot.a1[1], border = NA, col = "#00FF0040")

xplot.c2 = get.cell.meta.data("xplot", "c", 2)
yplot.c2 = get.cell.meta.data("yplot", "c", 2)
xplot.d2 = get.cell.meta.data("xplot", "d", 3)
yplot.d2 = get.cell.meta.data("yplot", "d", 3)
draw.sector(start.degree = xplot.c2[1], end.degree = xplot.d2[2], rou1 = yplot.c2[2], rou2 = yplot.c2[1], border = NA, col = "#0000FF40")

xplot.g2 = get.cell.meta.data("xplot", "g", 2)
yplot.g2 = get.cell.meta.data("yplot", "g", 2)
xplot.g3 = get.cell.meta.data("xplot", "g", 3)
yplot.g3 = get.cell.meta.data("yplot", "g", 3)
draw.sector(start.degree = xplot.g2[1], end.degree = xplot.g2[2], rou1 = yplot.g2[2], rou2 = yplot.g3[1], border = NA, col = "#00FFFF40")

xplot.e2 = get.cell.meta.data("xplot", "e", 2)
yplot.e2 = get.cell.meta.data("yplot", "e", 2)
xplot.e3 = get.cell.meta.data("xplot", "e", 3)
yplot.e3 = get.cell.meta.data("yplot", "e", 3)
xplot.f2 = get.cell.meta.data("xplot", "f", 2)
yplot.f2 = get.cell.meta.data("yplot", "f", 2)
xplot.f3 = get.cell.meta.data("xplot", "f", 3)
yplot.f3 = get.cell.meta.data("yplot", "f", 3)
draw.sector(start.degree = xplot.e2[1], end.degree = xplot.f2[2], rou1 = yplot.e2[2], rou2 = yplot.e3[1], border = NA, col = "#FFFF0040")
show.index()
circos.clear()
@

\begin{figure}
\begin{center}
<<label=sectorhighlight, fig = TRUE, echo = FALSE>>=
<<sectorhighlight>>
@
\end{center}
\caption{Hightlight sectors}
\label{fig:sectorhighlight}
\end{figure}


\subsection{Do not forget {\tt circos.clear}}
You should always call {\tt circos.clear} to complete the circos plottings. Because there are several
global variables tracing the status of the plot such as the index and position for the newest track.
Such variables should be reset before drawing any new circos figures.

\section{Advanced plottings}

\subsection{Draw part of the circos layout}
{\tt canvas.xlim} and {\tt canvas.ylim} in {\tt circos.par} is useful to draw only part of circle. In the example,
only sectors between $0^\circ$ to $90^\circ$ are plotted (figure \ref{fig:part}). First, four sectors
with the same width are initialized. Then only the first sector is drawn with points and lines. From figure \ref{fig:part},
we in fact created the whole circle, but only a quarter of the circle is in the canvas region. Codes are as follows. 

<<eval=FALSE, echo=TRUE>>=
par(mar = c(1, 1, 1, 1))
circos.par("canvas.xlim" = c(0, 1), "canvas.ylim" = c(0, 1),
    "clock.wise" = FALSE, "gap.degree" = 0)
factors = letters[1:4]
circos.initialize(factors = factors, xlim = c(0, 1))
circos.trackPlotRegion(factors = factors, ylim = c(0, 1),
    bg.border = NA)
circos.updatePlotRegion(sector.index = "a", bg.border = "black")
circos.points(runif(100), runif(100), pch = 16, cex = 0.5)
circos.trackPlotRegion(factors = factors, ylim = c(0, 1),
    bg.border = NA)
circos.updatePlotRegion(sector.index = "a", bg.border = "black")
circos.lines(1:100/100, runif(100), pch = 16, cex = 0.5)
@


<<label=figpart, echo=FALSE, eval=FALSE>>=
library(circlize)
par(mfrow = c(2, 1))
par(mar = c(1, 1, 1, 1))
circos.par("clock.wise" = FALSE, "gap.degree" = 0)
factors = letters[1:4]
circos.initialize(factors = factors, xlim = c(0, 1))
circos.trackPlotRegion(factors = factors, ylim = c(0, 1))
circos.updatePlotRegion(sector.index = "a", bg.border = "black")
circos.points(runif(100), runif(100), pch = 16, cex = 0.5)
circos.trackPlotRegion(factors = factors, ylim = c(0, 1), bg.border = NA)
circos.updatePlotRegion(sector.index = "a", bg.border = "black")
circos.lines(1:100/100, runif(100), pch = 16, cex = 0.5)
circos.clear()

rect(0, 0, 1, 1)
text(0, 0, 0, adj = c(0.5, 1))
text(1, 0, 1, adj = c(0.5, 1))
text(0, 1, 1, adj = c(0.5, 0))


par(mar = c(1, 1, 1, 1))
circos.par("canvas.xlim" = c(0, 1), "canvas.ylim" = c(0, 1),"clock.wise" = FALSE, "gap.degree" = 0, points.overflow.warning = FALSE)
factors = letters[1:4]
circos.initialize(factors = factors, xlim = c(0, 1))
circos.trackPlotRegion(factors = factors, ylim = c(0, 1), bg.border = NA)
circos.updatePlotRegion(sector.index = "a", bg.border = "black")
circos.points(runif(100), runif(100), pch = 16, cex = 0.5)
circos.trackPlotRegion(factors = factors, ylim = c(0, 1), bg.border = NA)
circos.updatePlotRegion(sector.index = "a", bg.border = "black")
circos.lines(1:100/100, runif(100), pch = 16, cex = 0.5)
circos.clear()
box()
par(xpd = NA)
text(0, 0, 0, adj = c(0.5, 1))
text(1, 0, 1, adj = c(0.5, 1))
text(0, 1, 1, adj = c(0.5, 0))
@

\begin{figure}
\begin{center}
<<label=figpart, fig = TRUE, echo = FALSE, height=8, width=4>>=
<<figpart>>
@
\end{center}
\caption{Part of the circos layout}
\label{fig:part}
\end{figure}

\subsection{Combine two parts of circos layouts}
Since the circos layout by {\tt circlize} is finally plotted in an ordinary R plotting system.
Two seperated circos layouts can be plotted together by some tricks. Here the key is 
{\tt par(new = TRUE)} which allows to draw a new figure on the previous canvas region.
{\bf Just remember the radius of the circos is always 1.}

The first example is to draw one outer circos and an inner circos (figure \ref{fig:nested}).

<<eval=FALSE, echo=TRUE>>=
library(circlize)
par(mar = c(1, 1, 1, 1))
factors = letters[1:4]
circos.initialize(factors = factors, xlim = c(0, 1))
circos.trackPlotRegion(ylim = c(0, 1), panel.fun = function(x, y) {
    circos.text(0.5, 0.5, "outer circos")
})
circos.clear()

par(new = TRUE)
circos.par("canvas.xlim" = c(-2, 2), "canvas.ylim" = c(-2, 2))
factors = letters[1:3]
circos.initialize(factors = factors, xlim = c(0, 1))
circos.trackPlotRegion(ylim = c(0, 1), panel.fun = function(x, y) {
    circos.text(0.5, 0.5, "inner circos")
})
circos.clear()
@


<<label=fignested, echo=FALSE, eval=FALSE>>=
library(circlize)

layout(rbind(c(1,1,2,2), c(0, 3, 3,0)))
par(mar = c(2, 2, 2, 2))
factors = letters[1:4]
circos.initialize(factors = factors, xlim = c(0, 1))
circos.trackPlotRegion(ylim = c(0, 1), panel.fun = function(x, y) {
    circos.text(0.5, 0.5, "outer circos")
})
circos.clear()
box()
axis(side = 1)
axis(side = 2)

circos.par("canvas.xlim" = c(-2, 2), "canvas.ylim" = c(-2, 2))
factors = letters[1:3]
circos.initialize(factors = factors, xlim = c(0, 1))
circos.trackPlotRegion(ylim = c(0, 1), panel.fun = function(x, y) {
    circos.text(0.5, 0.5, "inner circos")
})
circos.clear()
box()
axis(side = 1)
axis(side = 2)

factors = letters[1:4]
circos.initialize(factors = factors, xlim = c(0, 1))
circos.trackPlotRegion(ylim = c(0, 1), panel.fun = function(x, y) {
    circos.text(0.5, 0.5, "outer circos")
})
circos.clear()

par(new = TRUE)
circos.par("canvas.xlim" = c(-2, 2), "canvas.ylim" = c(-2, 2))
factors = letters[1:3]
circos.initialize(factors = factors, xlim = c(0, 1))
circos.trackPlotRegion(ylim = c(0, 1), panel.fun = function(x, y) {
    circos.text(0.5, 0.5, "inner circos")
})
circos.clear()
@

\begin{figure}
\begin{center}
<<label=fignested, fig = TRUE, echo = FALSE, height=8, width=8>>=
<<fignested>>
@
\end{center}
\caption{An outer and an inner circos layout}
\label{fig:nested}
\end{figure}

The second example is drawing two seperated circos layouts in which every
circos only contains a half (figure \ref{fig:twoseperate}).

<<eval=FALSE, echo=TRUE>>=
library(circlize)
par(mar = c(1, 1, 1, 1))
factors = letters[1:4]
circos.par("canvas.xlim" = c(-1, 1.5), "canvas.ylim" = c(-1, 1.5),
    start.degree = -45)
circos.initialize(factors = factors, xlim = c(0, 1))
circos.trackPlotRegion(ylim = c(0, 1), bg.col = NA, bg.border = NA)
circos.updatePlotRegion(sector.index = "a")
circos.text(0.5, 0.5, "first one")
circos.updatePlotRegion(sector.index = "b")
circos.text(0.5, 0.5, "first one")

circos.clear()

par(new = TRUE)
circos.par("canvas.xlim" = c(-1.5, 1), "canvas.ylim" = c(-1.5, 1),
    start.degree = -45)
circos.initialize(factors = factors, xlim = c(0, 1))
circos.trackPlotRegion(ylim = c(0, 1), bg.col = NA, bg.border = NA)
circos.updatePlotRegion(sector.index = "d")
circos.text(0.5, 0.5, "second one")
circos.updatePlotRegion(sector.index = "c")
circos.text(0.5, 0.5, "second one")

circos.clear()
@

<<label=figseperated, echo=FALSE, eval=FALSE>>=
library(circlize)
layout(rbind(c(1,1,2,2), c(0, 3, 3,0)))
par(mar = c(2, 2, 2, 2))


factors = letters[1:4]
circos.par("canvas.xlim" = c(-1, 1.5), "canvas.ylim" = c(-1, 1.5),
    start.degree = -45)
circos.initialize(factors = factors, xlim = c(0, 1))
circos.trackPlotRegion(ylim = c(0, 1), bg.col = NA, bg.border = NA)
circos.updatePlotRegion(sector.index = "a")
circos.text(0.5, 0.5, "first one")
circos.updatePlotRegion(sector.index = "b")
circos.text(0.5, 0.5, "first one")

circos.clear()
box()
axis(side = 1)
axis(side = 2)

circos.par("canvas.xlim" = c(-1.5, 1), "canvas.ylim" = c(-1.5, 1), start.degree = -45)
circos.initialize(factors = factors, xlim = c(0, 1))
circos.trackPlotRegion(ylim = c(0, 1), bg.col = NA, bg.border = NA)
circos.updatePlotRegion(sector.index = "d")
circos.text(0.5, 0.5, "second one")
circos.updatePlotRegion(sector.index = "c")
circos.text(0.5, 0.5, "second one")

circos.clear()
box()
axis(side = 1)
axis(side = 2)

factors = letters[1:4]
circos.par("canvas.xlim" = c(-1, 1.5), "canvas.ylim" = c(-1, 1.5), start.degree = -45, points.overflow.warning = FALSE)
circos.initialize(factors = factors, xlim = c(0, 1))
circos.trackPlotRegion(ylim = c(0, 1), bg.col = NA, bg.border = NA)
circos.updatePlotRegion(sector.index = "a")
circos.text(0.5, 0.5, "first one")
circos.updatePlotRegion(sector.index = "b")
circos.text(0.5, 0.5, "first one")

circos.clear()

par(new = TRUE)
circos.par("canvas.xlim" = c(-1.5, 1), "canvas.ylim" = c(-1.5, 1), start.degree = -45)
circos.initialize(factors = factors, xlim = c(0, 1))
circos.trackPlotRegion(ylim = c(0, 1), bg.col = NA, bg.border = NA)
circos.updatePlotRegion(sector.index = "d")
circos.text(0.5, 0.5, "second one")
circos.updatePlotRegion(sector.index = "c")
circos.text(0.5, 0.5, "second one")

circos.clear()

@

\begin{figure}
\begin{center}
<<label=figseperated, fig = TRUE, echo = FALSE, height=8, width=8>>=
<<figseperated>>
@
\end{center}
\caption{Two seperated circos layouts}
\label{fig:twoseperate}
\end{figure}

\subsection{Draw outside and combine with canvas coordinate}
Sometimes it is very useful to draw something outside the plotting region of cell. The following is a simple
example to illustrate such circumstance (figure \ref{fig:outside}). The text is drawn outside the cell.


<<label=figoutside, echo=FALSE, eval=FALSE>>=
library(circlize)
set.seed(12345)
par(mar = c(1, 1, 1, 1))
factors = letters[1:4]
circos.par("canvas.xlim" = c(-1.5, 1.5), "canvas.ylim" = c(-1.5, 1.5),
    "gap.degree" = 10)
circos.initialize(factors = factors, xlim = c(0, 1))
circos.trackPlotRegion(ylim = c(0, 1), panel.fun = function(x, y) {
    circos.points(1:20/20, 1:20/20)
})
circos.lines(c(1/20, 0.5), c(1/20, 3), sector.index = "d", straight = TRUE)
circos.text(0.5, 3, "mark", sector.index = "d", adj = c(0.5, 0))

circos.trackPlotRegion(ylim = c(0, 1), panel.fun = function(x, y) {
    circos.points(1:20/20, 1:20/20)
})
text(0, 0, "this is\nthe center", cex = 1.5)
legend("bottomleft", pch = 1, legend = "this is the legend")
circos.clear()
@


Since the finnal graph is drawn in an ordinary canvas plotting region, we can add additional graphs through
the traditional way. You can also see how {\tt text} and {\tt legend} work in the above example code.


\begin{figure}
\begin{center}
<<label=figoutside, fig = TRUE, echo = FALSE>>=
<<figoutside>>
@
\end{center}
\caption{Draw outside the cell and combine with canvas coordinate}
\label{fig:outside}
\end{figure}

\subsection{Draw figures with {\tt layout}}
You can use {\tt layout} to arrange multiple figures together (also it is available from {\tt par(mfrow)}
or {\tt par(mfcol)}) (figure \ref{fig:layout}). 

<<label=figlayout, echo=TRUE, eval=FALSE>>=
library(circlize)

set.seed(12345)
rand_color = function() {
    return(rgb(runif(1), runif(1), runif(1)))
}

layout(matrix(1:9, 3, 3))
for(i in 1:9) {
    factors = 1:8
    par(mar = c(0.5, 0.5, 0.5, 0.5))
    circos.par(cell.padding = c(0, 0, 0, 0))
    circos.initialize(factors, xlim = c(0, 1))
    circos.trackPlotRegion(ylim = c(0, 1), track.height = 0.05,
        bg.col = sapply(1:8, function(x) rand_color()),
        bg.border = NA)
    for(i in 1:20) {
        se = sample(1:8, 2)
        col = rand_color()
        col = paste(col, "40", sep = "")
        circos.link(se[1], runif(2), se[2], runif(2), col = col)
    }
    circos.clear()
}
@

\begin{figure}
\begin{center}
<<label=figlayout, fig = TRUE, echo = FALSE>>=
<<figlayout>>
@
\end{center}
\caption{Draw multiple figures by {\tt layout}}
\label{fig:layout}
\end{figure}

\end{document}
