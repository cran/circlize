% \VignetteIndexEntry{Introduction to circlize package}
% \VignetteDepends{circlize}
% \VignetteKeywords{circos R}
% \VignetteKeywords{ideogram}
% \VignetteKeywords{circlize}
% \VignettePackage{circlize}


\documentclass{article}

\title{An introduction to {\it circlize} package}

\author{Zuguang Gu {\tt <z.gu@dkfz.de>}}
\usepackage[margin=1in, a4paper]{geometry}

\usepackage{Sweave}
\usepackage{hyperref}

\begin{document}

\maketitle 

\section{Introduction}
Circular layout is very useful to represent complicated information, especially for genomic data. It 
has advantages to visuallize data with long axes or large amount of categories, described with multiple tracks. Another unique feature for circular layout is
it is effective to visuallize relations between elements.

{\it Circos} (\url{http://circos.ca}) is an extraordinarily cool software to draw such circular layout which is broadly used in real applications, not just
popular in Genomic but in a lot of other areas as well. It is not only a way to visualize data, 
but enhances the representation of scientific results into a level of aesthetics. Therefore, most people call figures with circular layout as `circos plot'.
Here the {\it circlize} package aims to implement {\it Circos} in R. One advantage for the implementation in R is that R is an ideal
enrivonment which provides seamless connectioin between data analysis and data visualization. This package is not a front-end wrapper
to generate configuration files for {\it Circos}, but completely coded in R style by using R's elegant statistical and graphic eigine.  
We aim to keep the flexibility and configurability of {\it Circos}, also make the package more straightforward to use and enhance it to support more types of graphics. 

\section{Principle of design}
Since most of the figures are composed of simple graphics, such as points, lines, polygon (for filled color) {\it et al},
{\it circlize} implements low level functions for drawing graphics in circular layout, so that more higher level
graphics can be easily comprised by low level graphics. This principle ensures the generality of generating circos plot
that types of high level graphics are not restricted by the software but determined by users.

Currently there are following graphic functions that can be used for plotting, they are similar to the functions without {\tt circos.}
prefix from the traditional graphic engine (you can also see the correspondence in figure \ref{fig:correspondence}):

\begin{figure}
\begin{center}
<<label=figcorrespondence, fig = TRUE, echo = FALSE, results=hide>>=
source("src/intro-00-correspondence.R")
@
\end{center}
\caption{Correspondence between graphic functions in {\it circlize} and in traditional R graphic engine.}
\label{fig:correspondence}
\end{figure}

\begin{itemize}
  \item {\tt circos.points}: draw points in a cell, similar as {\tt points}.
  \item {\tt circos.lines}: draw lines in a cell, similar as {\tt lines}.
  \item {\tt circos.rect}: draw rectangle in a cell, similar as {\tt rect}.
  \item {\tt circos.polygon}: draw polygon in a cell, similar as {\tt polygon}.
  \item {\tt circos.text}: draw text in a cell, similar as {\tt text}.
  \item {\tt circos.axis}: draw axis in a cell, functionally similar as {\tt axis} but with more features.
  \item {\tt circos.link}: this maybe the unique feature for circos layout to represent relationships between elements.
\end{itemize}

For drawing points, lines and text in cells through the whole track (among several sectors), the following functions are available:

\begin{itemize}
  \item {\tt circos.trackPoints}: this can be replaced by {\tt circos.points} through a {\tt for} loop.
  \item {\tt circos.trackLines}: this can be replaced by {\tt circos.lines} through a {\tt for} loop.
  \item {\tt circos.trackText}: this can be replaced by {\tt circos.text} through a {\tt for} loop.
\end{itemize}

Also, the function drawing histograms in the whole track is available:

\begin{itemize}
  \item {\tt circos.trackHist}
\end{itemize}

Functions to arrange the circular layout:

\begin{itemize}
  \item {\tt circos.trackPlotRegion}: create plotting regions of cells in a track
  \item {\tt circos.updatePlotRegion}: update an existed cell
  \item {\tt circos.par}: graphic parameters
  \item {\tt circos.clear}: reset graphic parameters and internal variables
\end{itemize}

Theoretically, you are able to draw most kinds of circos figures by the above functions. 
As you will see, all figures in the four vignettes are generated by {\it circlize} package.

The following part of this vignette is structured as follows: First there is an example
to give a quick glance of how to draw a circular layout by {\it circlize}. Then it tells you the basic principle
(or the order of using the circos functions) for drawing. After that there are detailed explainations
of graphic parameters, coordinates and low level functions. Finally it would tell you some tricks
for drawing more complicated circos plot.

\section{A quick glance}
Following is an example to show the basic feature and usage of {\it circlize} package. 
First generate some data. There needs to have a factor to represent categories,
values on x-axis, and values on y-axis.

<<echo=TRUE, eval=FALSE>>=
set.seed(12345)
n = 1000
a = data.frame(factor = sample(letters[1:8], n, replace = TRUE),
    x = rnorm(n), y = runif(n))
@

Initialize the layout. In this step, the {\tt circos.initialize} function allocates sectors along
the circle according to ranges of x-values in different categories. E.g,
if there are two categories, range for x-values in the first category is {\tt c(0, 2)}
and range for x-values in the second category is {\tt c(0, 1)}, the first category
would hold approximately $67\%$ areas of the circle.
Here we only need x-values because all cells in a sector share the same
x-ranges.

<<echo=TRUE, eval=FALSE>>=
library(circlize)
par(mar = c(1, 1, 1, 1), lwd = 0.1, cex = 0.7)
circos.par("default.track.height" = 0.1)
circos.initialize(factors = a$factor, x = a$x)
@

Draw the first track (figure \ref{fig:example}, top left). Before drawing any track 
we need to know that all tracks should firstly be created by {\tt circos.trackPlotRegion}, then
those low level functions can be applied (recall in traditional R graphic eigine, 
you need first call {\tt plot.default} and then you can use functions such as {\tt points} and {\tt lines} to add graphics on it).
Since x-lims for cells in the track have already been defined in the initialization step, 
so here we only need to specify the y-lims for each cell, either by {\tt y}
or {\tt ylim} argument. 

We also draw axes for cells in the first track, The axis for each cell is drawn by {\tt panel.fun} argument. 
{\tt circos.trackPlotRegion} creates plotting region cell by cell and the {\tt panel.fun}
is actually executed immediately after the creation of the plotting region for a cell. So {\tt panel.fun} actually means
drawing graphics in the ``current cell''. After that, draw points
through the whole track by {\tt circos.trackPoints}. Finally, add two texts in a certain cell
(the cell is specified by {\tt sector.index} and {\tt track.index} argument). In drawing the second
text, we do not specify {\tt track.index} because the package knows we are now in the first track.

Here what should be noted is that the first track has a index number of 1.
An internal variable which traces the tracks would set the `current track index' to 1. So if the track
index is not specified in the plotting functions such as {\tt circos.trackPoints} and {\tt circos.text}
which are called after the creation of the track, the current track index would be assigned internally.
 (details would be explained in the following sections).

<<echo=TRUE, eval=FALSE>>=
circos.trackPlotRegion(factors = a$factor, y = a$y,
    panel.fun = function(x, y) {
        circos.axis()
})
col = rep(c("#FF0000", "#00FF00"), 4)
circos.trackPoints(a$factor, a$x, a$y, col = col,
    pch = 16, cex = 0.5)
circos.text(-1, 0.5, "left", sector.index = "a", track.index = 1)
circos.text(1, 0.5, "right", sector.index = "a")
@

Draw the second track (figure \ref{fig:example}, top right). There are histograms in the track. The {\tt circos.trackHist}
can also create a new track because drawing histogram is really high level, so we do not need to call {\tt circos.trackPlotRegion}. The track index for this track is 2.

<<echo=TRUE, eval=FALSE>>=
bgcol = rep(c("#EFEFEF", "#CCCCCC"), 4)
circos.trackHist(a$factor, a$x, bg.col = bgcol, col = NA)
@

Draw the third track (figure \ref{fig:example}, middle left). Different background colors for cells can be assigned. So it may highlight some
features of the {\it circlize} package. Here some meta data for a cell can be obtained by {\tt get.cell.meta.data}. This function needs
{\tt sector.index} and {\tt track.index} arguments, and if they are not specified, it means
it is the current sector index and the current track index.

<<echo=TRUE, eval=FALSE>>=
circos.trackPlotRegion(factors = a$factor, x = a$x, y = a$y,
  panel.fun = function(x, y) {
      grey = c("#FFFFFF", "#CCCCCC", "#999999")
      i = get.cell.meta.data("sector.numeric.index")
      circos.updatePlotRegion(bg.col = grey[i %% 3 + 1])
      circos.points(x[1:10], y[1:10], col = "red", pch = 16, cex = 0.6)
      circos.points(x[11:20], y[11:20], col = "blue", cex = 0.6)
  })
@

You can update an existed cell by specifying {\tt sector.index} and {\tt track.index} in {\tt circos.updatePlotRegion}.
The function erases graphics which have been drawn. Here we erase graphics in one cell in track 2, sector {\tt d}
and re-draw some points (figure \ref{fig:example}, middle right). {\tt circos.updatePlotRegion} can not modify the {\tt xlim}
and {\tt ylim} of the cell as well as other settings related to the position of the cell.

<<echo=TRUE, eval=FALSE>>=
circos.updatePlotRegion(sector.index = "d", track.index = 2)
circos.points(x = -2:2, y = rep(0, 5))
@}

Draw the fourth track (figure \ref{fig:example}, bottom left). Here you can choose different line types which is similar as {\tt type} argument in {\tt lines}.

<<echo=TRUE, eval=FALSE>>=
circos.trackPlotRegion(factors = a$factor, y = a$y)
circos.trackLines(a$factor[1:100], a$x[1:100], a$y[1:100], type = "h")
@

Draw links (figure \ref{fig:example}, bottom right). Links can be from point to point, point to interval or interval to interval.
Some of the arguments would be explained in the following sections.

<<echo=TRUE, eval=FALSE>>=
circos.link("a", 0, "b", 0, h = 0.4)
circos.link("c", c(-0.5, 0.5), "d", c(-0.5,0.5), col = "red",
    border = "blue", h = 0.2)
circos.link("e", 0, "g", c(-1,1), col = "green", lwd = 2, lty = 2)
@

Finally we need to clean in order to reset the graphic parameters and internal variables, so it will not mess up your next plotting.

<<echo=TRUE, eval=FALSE>>=
circos.clear()
@

\begin{figure}
\begin{center}
<<label=figexample, fig = TRUE, echo = FALSE, height = 18, width=12, results=hide>>=
source("src/intro-01-glance.R")
@
\end{center}
\caption{A step-by-step example by {\it circlize}}
\label{fig:example}
\end{figure}

The final figure looks like figure \ref{fig:example}.

\section{Details}
In this section, more details of the package would be explained.

\subsection{Coordinate transformation}
There is a {\bf data coordinate} in which the range for x-axis and y-axis is the range of data,
a {\bf polar coordinate} to allocates graphics on the circle and a {\bf canvas coordinate} which really
draws the graphics (figure \ref{fig:transformation}). The package would first transform from the data
coordinate to a polar coordinate and finally transform into the canvas coordinate.

\setkeys{Gin}{width=0.5\textwidth}
\begin{figure}
\begin{center}
<<label=figtransformation, fig = TRUE, echo = FALSE, height=5.64, width=2.5, results=hide>>=
source("src/intro-03-transformation.R")
@
\end{center}
\caption{Transformation between different coordinates. Top: data coordinate; Middle: polar coordinate; Bottom: canvas coordinate.}
\label{fig:transformation}
\end{figure}
\setkeys{Gin}{width=0.8\textwidth}


The finnal canvas coordinate is in fact an ordinary coordinate in R plotting system with
x-range from -1 to 1 and y-range from -1 to 1 by default.

{\it {\bf It should be noted that the circular layout is always (or mostly except you want to draw something out of the circle) 
drawn inside the circle which has radius of 1 (unit circle), from outside to inside. } }

However, for users, they only need to imagine that each cell is a normal rectangular plotting region (data coordinate) in
which x-lim and y-lim are ranges of data in the category respectively. The {\it circlize} package would
know which cell you are drawing in and do all the transformations.


\subsection{Rules for drawing circular layout}
The rules for drawing circular layout is rather simple. It follows the sequence of
``initialize - create track - draw graphics - create track - draw graphics - ... - clear'' (figure \ref{fig:order}).
See following:

\setkeys{Gin}{width=\textwidth}
\begin{figure}
\begin{center}
<<label=figorder, fig = TRUE, echo = FALSE, height=6, width=7, results=hide>>=
source("src/intro-02-order.R")
@
\end{center}
\caption{Order of drawing circular layout}
\label{fig:order}
\end{figure}
\setkeys{Gin}{width=0.8\textwidth}

\begin{enumerate}
  \item Initialize the layout using {\tt circos.initialize}. Since circular layout in fact visualizes data which is in categories,
        there should be a factor and a x-range variable to allocate categories into sectors.
  \item Create plotting regions for the new track and add graphics. The new track is created just inside
        the previously created one and the index of the track is added by 1 automatically. Only after the creation of the track can you
        add other graphics on it. There are three ways to do the plotting job.
        \begin{enumerate}
            \item After the creation of the track, use low level graphic function like {\tt circos.points},
                  {\tt circos.lines}, ... to add graphics cell by cell. It always involves
                  a {\tt for} loop.
            \item Use {\tt circis.trackPoints}, {\tt circos.trackLines}, ... to draw same style
                  of graphics through all cells simultaneously. However, it is not recommended because
                  it would make you a little confused and also it cannot draw complicated graphics.
            \item Use {\tt panel.fun} argument in {\tt circos.trackPlotRegion} to draw
                  graphics immediately after the creation of a certain cell. {\tt panel.fun} needs
                  two arguments {\tt x} and {\tt y} which are x-values and y-values that
                  in the current category. This subset operation would be applied automatically.
        \end{enumerate}
        
        Plotting regions for cells that have been created can be updated by {\tt circos.updatePlotRegion}.
        {\tt circos.updatePlotRegion} will erase everything that you have already added in the plotting region of the cell.
        
        Low level functions such as {\tt circos.points} can be applied to any created cell by specifying
        {\tt sector.index} and {\tt track.index}.
  \item Repeat step 2 to add more tracks on the circle.
  \item Call {\tt circos.clear} to do cleanings.
\end{enumerate}

As metioned above, there are three ways to add graphics on the created track. 1. create plotting regions for the whole track
and then add graphics by specifying {\tt sector.index} and {\tt track.index}. In the following pseudo code, {\tt x1}, {\tt y1}
are data points in a given cell, which means you need to do data subsetting by yourself.

\begin{Schunk}
\begin{Sinput}
> circos.initialize(factors, xlim)
> circos.trackPlotRegion(factors, ylim)
> for(sector.index in all.sector.index) {
+     circos.points(x1, y1, sector.index)
+     circos.lines(x2, y2, sector.index)
+ }
\end{Sinput}
\end{Schunk}

2. add graphics through a batch mode. This can be replaced by {\tt circos.points} or {\tt circos.lines} in a {\tt for} loop.
In the following code, you need to specifying the {\tt factors} and now {\tt x1} and {\tt y1} are data points for all categories.
The data points for a given cell will be subsetted according the {\tt factors}.
\begin{Schunk}
\begin{Sinput}
> circos.initialize(factors, xlim)
> circos.trackPlotRegion(factors, ylim)
> circos.trackPoints(factors, x1, y1)
> circos.trackLines(factors, x2, y2)
\end{Sinput}
\end{Schunk}

3. use a panel function to add self-defined graphics as soon as the cell has been created. This is the way I recommend since when
you look at {\tt panel.fun}, it is just like adding graphics in traditional R graphics system. There will be a more detailed explaination
of {\tt panel.fun} argument in the following section.

\begin{Schunk}
\begin{Sinput}
> circos.initialize(factors, xlim)
> circos.trackPlotRegion(factors, all_x, all_y, ylim,
+   panel.fun = function(x, y) {
+     circos.points(x, y)
+     circos.lines(x, y)
+ })
\end{Sinput}
\end{Schunk}

There is several internal variables keeping tracing of the current sector and track when applying {\tt circos.trackPlotRegion} and {\tt circos.updatePlotRegion}.
So although functions like {\tt circos.points}, {\tt circos.lines} need to specify the index for sector and track,
they will take the current calculated ones by default. As a result,
if you draw points, lines, text, {\it et al} just after the creation of the track or cell, you do not need to set the sector
index and the track index explicitly and it is just drawn in the most nearly created cell. Note again, only {\tt circos.trackPlotRegion}
and {\tt circos.updatePlotRegion} would reset the current track index and sector index.

Finally, in {\it circlize} package, function with prefix {\tt circos.track} would affect all cells in a track.



\subsection{Sectors and tracks}

A circular layout is composed of sectors and tracks, as illustrated in figure \ref{fig:coordinate}.
The red circle is the track and the blue one is the sector. The intersection of a sector and 
a track is called a cell which can be thought as an imaginary plotting region for data points in a certain category (data coordinate). 

\begin{figure}
\begin{center}
<<label=figcoordinate, fig = TRUE, echo = FALSE, results=hide>>=
source("src/intro-04-coordinate.R")
@
\end{center}
\caption{Coordinate in circos layout}
\label{fig:coordinate}
\end{figure}


Sectors are first allocated on the circle and determined by {\tt circos.initialize} and track allocation in the radical direction is then determined by {\tt circos.trackPlotRegion}.
{\tt circos.initialize} needs a category variable and data value which implicates the range of data in each category. The range
of data can be specified either by {\tt x} or {\tt xlim}.

\begin{Schunk}
\begin{Sinput}
> circos.initialize(factors, x)
> circos.initialize(factors, xlim)
\end{Sinput}
\end{Schunk}

There are something very important that should be noted in the initialization step. In this step, not only the width
of each sector is assigned, but also the order of each sector on the circle would be determined. 
{\bf Order of the sectors are determined by the order of levels of the factor}. So if you want to change the order
of the sectors, just change of the level of the {\tt factors} variable. The following codes would generate different figures (figure \ref{fig:factor}):

\begin{Schunk}
\begin{Sinput}
> fa = c("d", "f", "e", "c", "g", "b", "a")
> f1 = factor(fa)
> circos.initialize(factors = f1, xlim = c(0, 1))
> f2 = factor(fa, levels = fa)
> circos.initialize(factors = f2, xlim = c(0, 1))
\end{Sinput}
\end{Schunk}

\setkeys{Gin}{width=\textwidth}
\begin{figure}
\begin{center}
<<label=figfactor, fig = TRUE, echo = FALSE, width=8, height=4, results=hide>>=
source("src/intro-05-factor.R")
@
\end{center}
\caption{Different {\tt factor} order in the initialization step.}
\label{fig:factor}
\end{figure}
\setkeys{Gin}{width=0.8\textwidth}

If {\tt x} which is the x-values corresponding
to {\tt factors} is specified, the range for x-values in different categories would be calculated according to {\tt factors}
automatically. And if {\tt xlim} is specified, it should be either a matrix which has same number of rows as the length
of the level of {\tt factors} or a two-element vector. If it is a two-element vector, it would be extended to a matrix which 
has the same number of rows as the length of {\tt factors} levels. Here, every row in {\tt xlim} corresponds to the x-ranges
of a category and the order of rows in {\tt xlim} corresponds to the order of levels of {\tt factors}.

Under the default settings, width of sectors are calculated according to the range of data in each category. In some circumstance,
you many want to manually set the width of each sector (figure \ref{fig:sectorwidth}). Normally it is not a good idea to change the default settings, since width
of sectors can reflect useful information of your data. However, sometimes it is useful to set the width of sectors such as you
want to draw your data only in half of the circle and in the other half of the circle, you want to zoom in some part of your data.
For example, someone may want to draw 24 chromosomes in half of the circle and zoom in two chromosomes at the other half of the circle (As you can see the example in the "How to draw ideogram" vignette).
The width of sectors can be set by {\tt sector.width} argument in {\tt circos.initialize}. The value for the argument should be a vector
with length of either one or as same as the number of categories (again, order of {\tt sector.width} vector corresponds to the order of levels of {\tt factors}). {\tt sector.width} is some kind of ratio or relative values, and the values
will be scaled to percentage later (e.g. if you set {\tt sector.width} to {\tt c(1, 3)}, it will be scaled as {\tt c(0.25, 0.75)}).

Example codes for sector zoomings look like:

<<echo=TRUE, eval=FALSE>>=
factors = sample(letters[1:6], 100, replace = TRUE)
x = rnorm(100)
y = rnorm(100)
zoomed_factor = factors[factors %in% c("a", "b")]
zoomed_factor[zoomed_factor == "a"] = "a_zoomed"
zoomed_factor[zoomed_factor == "b"] = "b_zoomed"
zoomed_x = x[factors %in% c("a", "b")]
zoomed_y = y[factors %in% c("a", "b")]

# attached to the origin data
factors = c(factors, zoomed_factor)
factors = factor(factors, levels = c(letters[1:6], "a_zoomed", "b_zoomed"))
x = c(x, zoomed_x)
y = c(y, zoomed_y)
xrange = tapply(x, factors, function(x) max(x) - min(x))

# see how to scale sector 1:6 to first half of circle and scale sector 7:8
# to the other half
circos.initialize(factors, x = x,
    sector.width = c(xrange[1:6]/sum(xrange[1:6]), xrange[7:8]/sum(xrange[7:8])))
circos.trackPlotRegion(factors, x = x, y = y, panel.fun = function(x, y) {
    circos.points(x, y)
    xlim = get.cell.meta.data("xlim")
    ylim = get.cell.meta.data("ylim")
    sector.index = get.cell.meta.data("sector.index")
    circos.text(mean(xlim), ylim[2] + 0.2*(ylim[2] - ylim[1]), 
        sector.index, adj = c(0.5, 0))
})

# if you want to add links from unzoomed sectors to zoomed sectors
circos.link("a", get.cell.meta.data("cell.xlim", sector.index = "a"),
    "a_zoomed", get.cell.meta.data("cell.xlim", sector.index = "a_zoomed"),
    border = NA, col = "#00000010")
circos.clear()
@

\begin{figure}
\begin{center}
<<label=figsectorwidth, fig = TRUE, echo = FALSE, results=hide>>=
source("src/intro-05-sectorwidth.R")
@
\end{center}
\caption{manually set the sector width}
\label{fig:sectorwidth}
\end{figure}

{\bf Since all cells in one sector while in different tracks share the same x-ranges}, for each track, we only need to specify the y-ranges
for cells. Similar as {\tt circos.initialize}, {\tt circos.trackPlotRegion} can also receive either {\tt y} or {\tt ylim} argument
to specify the range of y-values. There is also a {\tt force.ylim} argument to sepcify whether all cells in one track should
share the same y-ranges. {\tt force.ylim} is only used along with {\tt y}.

\begin{Schunk}
\begin{Sinput}
> circos.trackPlotRegion(factors, y)
> circos.trackPlotRegion(factors, ylim)
\end{Sinput}
\end{Schunk}

In the track creation step, since all sectors are already allocated in the circle, if {\tt factors} argument is not set, 
{\tt circos.trackPlotRegion} would create plotting regions for all available sectors. Also, levels of {\tt factors} do not
need to be specified explicitly because the order of sectors has already be determined in the initialization step. If {\tt factors} is just a vector, it 
would be converted to factor automatically. And finally if users just create cells in part of sectors in the track (not all sectors), in fact, cells in remaining
unspecified sectors would also be created, but with no borders (pretending they are not created).

Cells are basic units in the circle and are independent with each other. After the creation of cells, they have self-contained meta values
of x-lim and y-lim (range of data in the category, data coordinate, ...). So if you are drawing in one cell, you do not need to consider things outside the cell and also you
do not need to consider you are in the circle. Just pretending it is rectangular. 

\begin{figure}
\begin{center}
<<label=figregion, fig = TRUE, echo = FALSE, results=hide>>=
source("src/intro-06-region.R")
@
\caption{Regions for a cell}
\label{fig:region}
\end{center}
\end{figure}

\setkeys{Gin}{width=0.6\textwidth}
\begin{figure}
\begin{center}
<<label=figdirection, fig = TRUE, echo = FALSE, width=4, height=8, results=hide>>=
source("src/intro-07-direction.R")
@
\end{center}
\caption{Sector directions. Sector orders are {\tt a}, ..., {\tt h}.}
\label{fig:direction}
\end{figure}
\setkeys{Gin}{width=0.8\textwidth}

\subsection{Graphic parameters}
Some basic parameters for the circular layout can be set through {\tt circos.par}. The paramters
are as follows, note some parameters can only be assigned before the initialization of the circular layout.

\begin{itemize}
    \item {\tt start.degree}: The starting degree at which the circle begins to draw. Note this degree is measured 
          in the standard polar coordinate which means it is always reverse clockwise. See figure \ref{fig:direction}.
    \item {\tt gap.degree}: Gap between two neighbour sectors. It can be a single value which means all gaps share same
          degree, or a vector which has same length as levels of the factors. See figure \ref{fig:direction} and figure \ref{fig:region}.
    \item {\tt track.margin}: Like {\tt margin} in Cascading Style Sheets (CSS), it is the blank area
          out of the plotting region, also outside of the borders. Since left and right margin are controlled
          by {\tt gap.degree}, only bottom and top margin need to be set. The value for the {\tt track.margin}
          is the percentage according to the radius of the unit circle. See figure \ref{fig:region}.
    \item {\tt cell.padding}: Padding of the cell. Like {\tt padding} in Cascading Style Sheets
          (CSS), it is the blank area around the plotting regions, but within the borders.
          The paramter has four values, which control the bottom, left, top and right padding
          respectively. The first and the third padding
          values are the percentages according to the radius of the unit circle and the second and
          fourth values are the degrees. See figure \ref{fig:region}.
    \item {\tt unit.circle.segments}: Since curves are simulated by a series of straight lines,
          this parameter controls the amount of segments to represent a curve. The minimal length
          of the line segment is the length of the unit circle ({\tt 2*pi}) divided by {\tt unit.circle.segments}. 
          More segments means better approximation for the curves while larger size if you generate figures as PDF format.
          (The name of this parameter may be a little hard to understand. I will try to change it with a better one.)
    \item {\tt default.track.height}: The default height of tracks. It is the percentage according to the radius
          of the unit circle. The height includes the top and bottom cell paddings but not the margins.
    \item {\tt points.overflow.warning}: Since each cell is in fact not a real plotting region but only
          an ordinary rectangle (or more precisely, rectangle-like), it does not eliminate points that are plotted out of
          the region. So if some points are out of the plotting region, by default, the 
          package would continue drawing the points and print warnings. But in some 
          circumstances, draw something out of the plotting region is useful, such as draw
          some legend or text. Set this value to {\tt FALSE} to turn off the warnings.
    \item {\tt canvas.xlim}: The coordinate for the canvas. The package is forced to draw unit circle, so
          the {\tt xlim} and {\tt ylim} for the canvas would be {\tt c(-1, 1)}. However, you can set it to a more broad
          interval if you want to draw other things out of the circle. By choose proper
          {\tt canvas.xlim} and {\tt canvas.ylim}, you can draw part of the circle. E.g. setting
          {\tt canvas.xlim} to {\tt c(0, 1)} and {\tt canvas.ylim} to {\tt c(0, 1)} would only draw
          circle in the region of {\tt (0, pi/2)}. 
    \item {\tt canvas.ylim}: The coordinate for the canvas.
    \item {\tt clock.wise}: The order of drawing sectors. Default is {\tt TRUE} which means clockwise (figure \ref{fig:direction}).
          But note that inside each cell, the direction of x-axis is always clockwise and direction of y-axis is always from inside to outside in the circle.
\end{itemize}

Default values for graphic paramters are in table \ref{table:gp}.

\begin{table}[ht]
\centering
\begin{tabular}{ll}
  \hline
parameter & default value \\ 
  \hline
{\tt start.degree} &     {\tt 0} \\ 
{\tt gap.degree} &    {\tt 1} \\ 
{\tt track.margin} &    {\tt c(0.01, 0.01)} \\ 
{\tt cell.padding} &    {\tt c(0.02, 1.00, 0.02, 1.00)} \\ 
{\tt unit.circle.segments} &    {\tt 500} \\ 
{\tt default.track.height} &    {\tt 0.2 } \\ 
{\tt points.overflow.warning} &    {\tt TRUE} \\ 
{\tt canvas.xlim} &    {\tt c(-1, 1)} \\ 
{\tt canvas.ylim} &    {\tt c(-1, 1)} \\ 
{\tt clock.wise} &    {\tt TRUE} \\ 
   \hline
\end{tabular}
\caption{Default graphic parameters}
\label{table:gp}
\end{table}

Parameters related to the allocation of sectors cannot be changed after the initialization of the circos layout.
So {\tt start.degree}, {\tt gap.degree}, {\tt canvas.xlim}, {\tt canvas.ylim} and {\tt clock.wise} can only
be modified before {\tt circos.initialize}. The second and the fourth element of {\tt cell.padding} (left and right paddings) can not
be modified either (or will be ignored).

\subsection{Create plotting region}
As described above, only after creating the plotting region can you add low level graphics on it. The minimal set
of arguments for this function is to set either {\tt y} or {\tt ylim} (remember order of rows of {\tt ylim} corresponds 
to the order of levels of {\tt factors} and if {\tt factors} is not specified, then it corresponds to the order of default 
sectors which is determined in the initialization step) which will assign range of y-values for the
track. {\tt circos.trackPlotRegion} create tracks for all sectors although in some case only part of them is visible.
If you only want to create the plotting regions but do not draw anything, you do not need to specify {\tt factors} and {\tt x}.
While if you want to draw something by {\tt panel.fun} as soon as you create the plotting region, then you need to specify {\tt factors}
and {\tt x} to pass the categories and values to {\tt panel.fun}. Graphic arguments such as {\tt bg.border} and {\tt bg.col}
can either be a scalar or a vector. If it is a vector, the length must be equal to the length of levels of {\tt factors}
and the order of these graphics arguments is also as same as the order of levels of {\tt factors}. With setting these graphics arguments you can create plot regions 
with different styles of borders and background colors. If you are confused with the {\tt factors} orders, you can also
customize the borders and background colors for the plotting region in {\tt panel.fun} (using {\tt get.cell.meta.data("cell.xlim")}
and {\tt get.cell.meta.data("cell.ylim")} to get the position of the plotting region).

\subsection{Update plotting region}
If {\tt track.index} is specified in {\tt circos.trackPlotRegion} and the specified track is already created,
the track will be updated with new graphics. In this case, settings related to the positions of the track such as the height of the track
can not be modified.

\begin{Schunk}
\begin{Sinput}
> circos.trackPlotRegion(data, ylim = c(0, 1), track.index = 1, ...)
\end{Sinput}
\end{Schunk}

For single cell, {\tt circos.updatePlotRegion} can be used to erase all graphics that have been already plotted in the cell.

\begin{Schunk}
\begin{Sinput}
> circos.updatePlotRegion(sector.index, track.index)
> circos.points(x, y, sector.index, track.index)
\end{Sinput}
\end{Schunk}


\begin{figure}
\begin{center}
<<label=figlines, fig = TRUE, echo = FALSE, results=hide>>=
source("src/intro-08-lines.R")
@
\end{center}
\caption{Line style settings}
\label{fig:lines}
\end{figure}

\subsection{Points}
Drawing points by {\tt circos.points} is similar as {\tt points} function. Possible usage is:

\begin{Schunk}
\begin{Sinput}
> circos.points(x, y)
> circos.points(x, y, sector.index, track.index)
> circos.points(x, y, pch, col, cex)
\end{Sinput}
\end{Schunk}

Since {\tt circos.points} is a low level function, it can only be applied to those
cells which have been created. If {\tt sector.index} or {\tt track.index} is not
specified, it would use the `current' index for sector and track which would be 
defined by the nearest {\tt circos.trackPlotRegion} or {\tt circos.updatePlotRegion}.

{\tt circos.trackPoints} can draw points in the whole cells on a same track.
However, it is the same if you use {\tt circos.points} in a {\tt for} loop.


\subsection{Lines}
Parameters for drawing lines by {\tt circos.lines} are similar to {\tt lines} function, 
as illustrated in figure \ref{fig:lines}. One additional feature is that the areas under/above lines can be 
specified by {\tt area} argument which can help you identifying the direction of y-axes. Also the base line for the area can be set by {\tt baseline}.
{\tt baseline} can be pre-defined string of {\tt bottom} or {\tt top}, or numeric values. {\tt baseline} is also workable
when {\tt lty} is set to {\tt h}.

Straight lines will be transformed to curves when mapping to circular layout (figure \ref{fig:linecurve}). Normally, 
curves can be approximated by a series of segmentations of straight lines. With more segmentations,
there would be better approximations, but with larger size if you generate the graph as pdf format, especially
for huge genomic data. So, in this package, the number of the segmentation can be controlled by {\tt circos.par("unit.circle.segments")}.
The length of minimal segment is the length of the unit circle divided by 
{\tt circos.par("unit.circle.segments")}. If you do not want such curve-transformations (such as
radical lines), you can set {\tt straight} argument to {\tt TRUE} (e.g. if it is a radical line.). 

\begin{figure}
\begin{center}
<<label=figlinecurve, fig = TRUE, echo = FALSE, results=hide>>=
source("src/intro-08-linescurve.R")
@
\end{center}
\caption{Straight lines will be transformed into curves in the circle}
\label{fig:linecurve}
\end{figure}

Possible usage for {\tt circos.lines} is:

\begin{Schunk}
\begin{Sinput}
> circos.lines(x, y)
> circos.lines(x, y, sector.index, track.index)
> circos.lines(x, y, col, lwd, lty, type, straight)
> circos.lines(x, y, col, area, baseline, border)
\end{Sinput}
\end{Schunk}

Similar as {\tt circos.points}, if no {\tt sector.index} or {\tt track.index} is
specified, `current' index would be used. Also, there is a {\tt circos.trackLines}
which is identical to {\tt circos.lines} in a {\tt for} loop.

\setkeys{Gin}{width=0.6\textwidth}
\begin{figure}
\begin{center}
<<label=figtext, fig = TRUE, echo = FALSE, width = 4, height = 8, results=hide>>=
source("src/intro-09-text.R")
@
\end{center}
\caption{Text facing settings}
\label{fig:text}
\end{figure}
\setkeys{Gin}{width=0.8\textwidth}

\subsection{Text}
Only the facing of text by {\tt circos.text} should be noted, as illustrated in figure \ref{fig:text}.
{\tt srt} in {\tt text} has been degenerated as {\tt facing} in {\tt circos.text} which  
support only six types of rotation pre-defined in {\tt c("inside", "outside", "reverse.clockwise", "clockwise", "downward", "bending")}.

But {\tt adj} argument is still applicable in {\tt circos.text}. Possible usage for {\tt circos.text} is:

\begin{Schunk}
\begin{Sinput}
> circos.text(x, y, labels)
> circos.text(x, y, labels, sector.index, track.index)
> circos.text(x, y, labels, facing, adj, cex, col, font)
\end{Sinput}
\end{Schunk}

In some circumstance, we may want the text facing clockwisely in right half of the circle while
reverse-closewisely in the left half of the circle. This can be easily done by self-defined codes.
Following is an example of {\tt panel.fun} and figure can be found in figure \ref{fig:text}. In the example,
{\tt get.cell.meta.data("xplot")} will return degrees corresponding to left and right margin of the specified cell.

\begin{Schunk}
\begin{Sinput}
panel.fun = function(x, y) {
    xlim = get.cell.meta.data("xlim")
    ylim = get.cell.meta.data("ylim")
    theta = mean(get.cell.meta.data("xplot")) %% 360
    sector.index = get.cell.meta.data("sector.index")
    if(theta < 90 || theta > 270) {
        text.facing = "clockwise"
        text.adj = c(0, 0.5)
    } else {
        text.facing = "reverse.clockwise"
        text.adj = c(1, 0.5)
    }
    circos.text(mean(xlim), ylim[1], labels,
        facing = text.facing, adj = text.adj)
}
\end{Sinput}
\end{Schunk}



There is also a {\tt circos.trackText} in the package.

\subsection{Rectangle}
If you imagin the plotting region in a cell as Cartesian coordinate, then it draws rectangles.
In the circle, the up and bottom edge become two arcs. Usage is similar as {\tt rect}, but it
can only draw one rectangle at a time.

\begin{Schunk}
\begin{Sinput}
> circos.rect(xleft, ybottom, xright, ytop)
> circos.rect(xleft, ybottom, xright, ytop, sector.index, track.index)
> circos.rect(xleft, ybottom, xright, ytop, col, border, lty, lwd)
\end{Sinput}
\end{Schunk}

\subsection{Polygon}
Similar as {\tt circos.rect} and {\tt polygon}, it draws a polygon through a series
of points in a cell:

\begin{Schunk}
\begin{Sinput}
> circos.polygon(x, y)
> circos.polygon(x, y, sector.index, track.index)
> circos.polygon(x, y, col, border, lty, lwd)
\end{Sinput}
\end{Schunk}

In figure \ref{fig:errorline}, the area of standard deviation of the smoothed line
is drawn by {\tt circos.polygon}. (Source code is in the examples section of {\tt circos.polygon}
help page.)

\begin{figure}
\begin{center}
<<label=figerrorline, fig = TRUE, echo = FALSE, results=hide>>=
source("src/intro-10-smooth.R")
@
\end{center}
\caption{Area of standard deviation of the smoothed line}
\label{fig:errorline}
\end{figure}


\begin{figure}
\begin{center}
<<label=figaxis, fig = TRUE, echo = FALSE, results=hide>>=
source("src/intro-11-axis.R")
@
\end{center}
\caption{Axis settings}
\label{fig:axis}
\end{figure}

\subsection{Axis}
Because there may be no space to draw y-axis, only drawing x-axis for each cell is supported by {\tt circos.axis}, as illustrated in figure \ref{fig:axis}.
A lot of styles for axis can be set such as the position and length of major ticks, the number of minor ticks,
the position and direction of the axis labels and the position of the x-axis. Note the adjustment of label strings is defined internally according
to differnet label directions to ensure the start/end position of the string is located near the major tick.

In figure \ref{fig:axis}, axis styles in different sectors are :

\begin{itemize}
  \item a: Major ticks are calculated automatically, other settings are default.
  \item b: Ticks are pointing to inside of the circle, facing of tick labels is set to {\tt default2}.
  \item c: Position of x-axis is {\tt bottom} of the cell.
  \item d: Ticks are pointing to inside of the circle, facing of tick labels is set to {\tt vertical\_left}.
  \item e: Self-defined major ticks.
  \item f: Self-defined major ticks and tick labels, no minor ticks.
  \item g: No ticks for both major and minor ones, facing of tick labels is set to {\tt vertical\_left}.
  \item h: Number of minor ticks between two major ticks is set to 2. Length of ticks is longer and axis labels are more away from ticks. Facing of tick labels is set to {\tt vertical\_right}.
\end{itemize}



For {\tt circos.axis}, possible usage is as follows. {\tt h} can be pre-defined string of {\tt bottom} or {\tt top}, or numeric values. 

\begin{Schunk}
\begin{Sinput}
> circos.axis(h)
> circos.axis(h, sector.index, track.index)
> circos.axis(h, major.at, labels, major.tick)
> circos.axis(h, major.at, labels, major.tick, labels.font, labels.cex,
+             labels.facing, labels.away.percentage)
> circos.axis(h, major.at, labels, major.tick, minor.ticks,
+             major.tick.percentage, lwd)
\end{Sinput}
\end{Schunk}

If you really want the y-axes, you can implement one by yourself. It is just a combination
of lines and text by using {\tt circos.lines} and {\tt circos.text}

\subsection{Links}
Links can be drawn by {\tt circos.link} from points and intervals (figure \ref{fig:link}, top). If both ends are points, then the link is represented
as a line. If one of the ends is an interval, the link would be a belt/ribbon. The link is in fact a quadratic curve. Links do not hold any position as tracks.
So links can be overlapping with tracks.

\setkeys{Gin}{width=\textwidth}
\begin{figure}
\begin{center}
<<label=figlink, fig = TRUE, echo = FALSE, width=8, height=8, results=hide>>=
source("src/intro-12-link.R")
@
\end{center}
\caption{Drawing links. Top right: set different positions of roots; Bottom left: set different height of two borders.}
\label{fig:link}
\end{figure}
\setkeys{Gin}{width=0.8\textwidth}

The position of the `root' of the link is controlled by {\tt rou1} and {\tt rou2} arguments. By default, it is the end position of the most recently created track.
So normally, you don't need to care about this setting.

The height of the link can be controlled by {\tt h} argument in {\tt circos.link}. The default height looks well from my view point, so you don't need to change this value.

Possible usage for {\tt circos.link} is:

\begin{Schunk}
\begin{Sinput}
> circos.link(sector.index1, 0, sector.index2, 0)
> circos.link(sector.index1, c(0, 1), sector.index2, 0)
> circos.link(sector.index1, c(0, 1), sector.index2, c(1, 2))
> circos.link(sector.index1, 0, sector.index2, 0, rou1, rou2, h, h2)
> circos.link(sector.index1, c(0, 1), sector.index2, 0, col, lwd, lty, border)
\end{Sinput}
\end{Schunk}

When the link represents as a belt/ribbon (i.e. link from point to interval or from interval to interval),
It can not ensure that one border is always below or above the other. Which means, in 
some cases, the two borders would intersect and it would make the link so ugly. It happens
especially when position of the two ends are too close or the width of one end is extremely large while
the width of the other end is too small. In that case, users can manually set height of the top
and bottom border by {\tt h} and {\tt h2}.

\subsection{The {\tt panel.fun} argument in {\tt circos.trackPlotRegion}}
{\tt panel.fun} argument in {\tt circos.trackPlotRegion} is useful to apply plottings as soon as the cell has been created. This self-defined
function need two arguments {\tt x} and {\tt y} which are data points that belong to this cell. The value for such values are automatically extracted from {\tt x} and {\tt y}
in {\tt circos.trackPlotRegion} function according to the category argument {\tt factors}. In the following example, {\tt x} in category {\tt a} in {\tt panel.fun}
would be {\tt 1:3} and {\tt y} values are {\tt 5:3}. If {\tt x} or {\tt y} in {\tt circos.trackPlotRegion} is {\tt NULL}, then {\tt x} or {\tt y} inside
{\tt panel.fun} is also {\tt NULL}.

\begin{Schunk}
\begin{Sinput}
> factors = c("a", "a", "a", "b", "b")
> x = 1:5
> y = 5:1
> circos.trackPlotRegion(factors = factors, x = x, y = y,
+     panel.fun = function(x, y) {
+         circos.points(x, y)
+     })
\end{Sinput}
\end{Schunk}

In {\tt panel.fun}, one thing important is that if you use any low level graphic functions, you don't need to specify {\tt sector.index} and {\tt track.index} explicitly.
Remember that when applying {\tt circos.trackPlotRegion}, cells in the track are created one after one. When a cell is created, the package would set the sector index
and track index of the cell as the `current' index for the sector and track. When the cell is created, {\tt panel.fun} would be exceeded afterward immediately. Without specifying
{\tt sector.index} and {\tt track.index}, the `current' one would be used and that's exactly what you need.

The advantage of {\tt panel.fun} is that it makes you feel you are using graphics functions in traditional graphics engine (You can see it is the same of using {\tt circos.points(x, y)} and {\tt points(x, y)}).
And you just pretend to draw in regular plotting regions. It will be much easier for users to understand and customize new graphics. 

Inside {\tt panel.fun}, more information of the `current' cell would be obtained through
{\tt get.cell.meta.data}. Also this funciton takes the `current' sector and `current' track by default,
Explaination of {\tt get.cell.meta.data} can be found in following section.


\subsection{High level plotting functions}
With those low-level function such as {\tt circos.points}, {\tt circos.lines},
more high level functions can be easily implemented. The package provides a high level 
function {\tt circos.trackHist} which draws histograms or the density
distributions of data (figure \ref{fig:hist}). So users would know how to implement other
high-level function to support graphs such as barplot, heatmap, ... according to the source code of {\tt circos.trackHist}.
In {\tt circos.trackHist}, first call {\tt hist} or {\tt density} to calculate the distribution, then
use {\tt circos.rect} or {\tt circos.lines} to draw histgrames or density distributions.

In figure \ref{fig:hist}, the first track is histograms in which all the {\tt ylim} are the same.
The second track is histograms in which {\tt force.ylim} is {\tt FALSE}.
The third and the fourth tracks are density distributions in which ylims
are forced same or not.


\begin{figure}
\begin{center}
<<label=fighist, fig = TRUE, echo = FALSE, results=hide>>=
source("src/intro-14-hist.R")
@
\end{center}
\caption{Histograms}
\label{fig:hist}
\end{figure}

In figure \ref{fig:heatmap} you would see heatmaps and cluster dendrograms in a circular layout. Heatmaps are
series of grids which can be drawn by {\tt circos.rect}. Dendrograms are series of lines which can be drawn
by {\tt circos.lines}. However, x-values for heatmaps and dendrograms are not really x-values but just index for
the grid/leaf (i.e., 1, 2, ... for grid/leaf 1, 2, ...), so it would be hard (or not proper) to make them
as general functions for circos plotting. Thus we do not provide such {\tt circos.heatmap} or {\tt circos.dendrogram}
in the package for public use. Anyway, we still wrote a not-full-functional {\tt circos.dendrogram} in the
demo code of the package. If you want to draw heatmap or dendrogram by your own, this may be 
helpful for you, especially when you want to customize a complecated phylogenic tree.

\begin{figure}
\begin{center}
<<label=figheatmap, fig = TRUE, echo = FALSE, results=hide>>=
source("src/intro-15-heatmap.R")
@
\end{center}
\caption{Heatmap with clustering}
\label{fig:heatmap}
\end{figure}

\subsection{Other functions}
{\tt draw.sector} can be used to draw sectors or part of a ring. This is useful if you want to hightlight some part of your circos plot.
As you can think, this function needs arguments of the position of circle center, the start degree and the end degree for sectors, 
and radius for two edges (or one edge) which may be the up or bottom border of a cell. These information can be obtained by {\tt get.cell.meta.data}. E.g. the start degree
and end degree can be obtained through {\tt cell.start.degree} and {\tt cell.end.degree}, and the position of the top border and bottom
border on the circle radius can be obtained through {\tt cell.top.radius} and {\tt cell.bottom.radius}. An example is as follows and see figure \ref{fig:sectorhighlight}
in which different colors correspond to different regions that need to be highlighted.


\begin{figure}
\begin{center}
<<label=sectorhighlight, fig = TRUE, echo = FALSE, results=hide>>=
source("src/intro-16-highlight.R")
@
\end{center}
\caption{Hightlight sectors}
\label{fig:sectorhighlight}
\end{figure}


Degrees and radius for any points in a given cell can be obtained by the core function {\tt circlize},
so you can highlight any region in the circular layout. Note {\tt circlize} always returns a matrix with two
columns in which the first column are degrees and the second column are radius for the points.

\begin{Schunk}
\begin{Sinput}
> circlize(x, y, sector.index, track.index)
> circlize(x, y)
\end{Sinput}
\end{Schunk}

Remember the color should be semi-transparent in the highlighted area. Usage for {\tt draw.sector} is:

\begin{Schunk}
\begin{Sinput}
> draw.sector(center, start.degree, end.degree, rou1)
> draw.sector(center, start.degree, end.degree, rou1, rou2)
> draw.sector(center, start.degree, end.degree, rou1, rou2, col, border, lwd, lty)
\end{Sinput}
\end{Schunk}

{\tt get.cell.meta.cell} can provide detailed information for a cell. It needs the index
of sector and track as arguments. As usual, it would use `current' index by default.

\begin{Schunk}
\begin{Sinput}
> get.cell.meta.data(name)
> get.cell.meta.data(name, sector.index, track.index)
\end{Sinput}
\end{Schunk}

Items that can be extracted by {\tt get.cell.meta.data} are:

\begin{itemize}
  \item {\tt sector.index}: The name (label) for the sector
  \item {\tt sector.numeric}.index: Numeric index for the sector. It is the numeric order of levels of {\tt factors} in initialization step.
  \item {\tt track.index}: Numeric index for the track
  \item {\tt xlim}: Minimal and maximal values on the x-axis
  \item {\tt ylim}: Minimal and maximal values on the y-axis
  \item {\tt xrange}: Range of {\tt xlim}
  \item {\tt yrange}: Range of {\tt ylim}
  \item {\tt cell.xlim}: Minimal and maximal values on the x-axis extended by cell paddings
  \item {\tt cell.ylim}: Minimal and maximal values on the y-axis extended by cell paddings
  \item {\tt xplot}: Right and left border degree for the plotting region in the unit circle.
                        The first element corresponds to the start point of values on x-axis ({\tt cell.xlm[1]})
                        and the second element corresponds to the end point of values on x-axis ({\tt cell.xlim[2]})
                        Since x-axis in data coordinate in cells are always clockwise, {\tt xplot[1]} is larger
                        than {\tt xplot[2]}.
  \item {\tt yplot}: Bottom and top radius value for borders of the plotting region. It is the value
                        of radius of arc corresponding to inner border or outer border.
  \item {\tt cell.start.degree}: Same as {\tt xplot[1]}
  \item {\tt cell.end.degree}: Same as {\tt xplot[2]}
  \item {\tt cell.bottom.radius}: Same as {\tt yplot[1]}
  \item {\tt cell.top.radius}: Same as {\tt yplot[2]}
  \item {\tt track.margin}: Margins for the cell
  \item {\tt cell.padding}: Paddings for the cell
\end{itemize}

With information returned by {\tt get.cell.meta.data}, you can customize the plotting region for each cell.
The following two tracks have the same style. The advantages for the second track is that you can add other
graphic such as reference lines and you will not be confused by the settings of factor orders.

<<echo=TRUE, eval=FALSE>>=
factors = letters[1:3]
circos.initialize(factors = factors, xlim = c(0, 1))
circos.trackPlotRegion(ylim = c(0, 1), bg.border = NA, bg.col = 1:3)
circos.trackPlotRegion(ylim = c(0, 1), bg.border = NA, bg.col = NA,
    panel.fun = function(x, y) {
        cell.xlim = get.cell.meta.data("cell.xlim")
        cell.ylim = get.cell.meta.data("cell.ylim")
        i = get.cell.meta.data("sector.numeric.index")
        circos.rect(cell.xlim[1], cell.ylim[1], cell.xlim[2], cell.ylim[2],
            col = i, border = NA)
})
@


\subsection{Get information of your circos plot}
You can get basic information of your current circos plot by {\tt circos.info}.
The function can be applied at any time.

\begin{Schunk}
\begin{Sinput}
> factors = letters[1:3]
> circos.initialize(factors = factors, xlim = c(1, 2))
> circos.info()
\end{Sinput}
\begin{Soutput}
All your sectors:
[1] "a" "b" "c"

All your tracks:
integer(0)

Your current sector.index is 
Your current track.index is 0
\end{Soutput}
\begin{Sinput}
> circos.trackPlotRegion(ylim = c(0, 1))
> circos.info(sector.index = "a", track.index = 1
\end{Sinput}
\begin{Soutput}
sector index: a
track index: 1
xlim: [1, 2]
ylim: [0, 1]

Your current sector.index is c
Your current track.index is 1
\end{Soutput}
\end{Schunk}

It can also add labels onto every cell by {\tt circos.info(plot = TRUE)}.

\subsection{Do not forget {\tt circos.clear}}
You should always call {\tt circos.clear} to complete the circos plottings. Because there are several
parameters for circos plot which can only be set before {\tt circos.initialize}. So before you draw the next
circos plot, you need to reset these parameters.

\subsection{A simple example of implementing high level graphics}
We will show you a simple example (figure \ref{fig:combine}) which combine several low level graphic function to construct a more complicated graphic for specific purpose.

In the following code, we first draw reference lines both from x-direction and y-direction. Then draw two rectangles which covers region of {\tt y > 1} and {\tt y < -1}.
Finally, add points to the region with different colors.

<<echo=TRUE, eval=FALSE>>=
library(circlize)
factors = sample(letters[1:6], 100, replace = TRUE)
x = rnorm(100)
y = rnorm(100)

par(mar = c(1, 1, 1, 1))
circos.initialize(factors = factors, x = x)
circos.trackPlotRegion(factors = factors, x = x, y = y, bg.col = "#EEEEEE",
    bg.border = NA, track.height = 0.4, panel.fun = function(x, y) {
    
    cell.xlim = get.cell.meta.data("cell.xlim")
    cell.ylim = get.cell.meta.data("cell.ylim")
    # reference lines
    for(xi in seq(cell.xlim[1], cell.xlim[2], length.out = 10)) {
        circos.lines(c(xi, xi), cell.ylim, lty = 2, col = "white") 
    }
    for(yi in seq(cell.ylim[1], cell.ylim[2], length.out = 5)) {
        circos.lines(cell.xlim, c(yi, yi), lty = 2, col = "white") 
    }
    
    xlim = get.cell.meta.data("xlim")
    ylim = get.cell.meta.data("ylim")
    circos.rect(xlim[1], 1, xlim[2], ylim[2], col = "#FF000020", border = NA)
    circos.rect(xlim[1], ylim[1], xlim[2], -1, col = "#00FF0020", border = NA)

    circos.points(x[y >= 1], y[y >= 1], pch = 16, cex = 0.8, col = "red")
    circos.points(x[y <= -1], y[y <= -1], pch = 16, cex = 0.8, col = "green")
    circos.points(x[y > -1 & y < 1], y[y > -1 & y < 1], pch = 16, cex = 0.5)
})

circos.clear()
@

\begin{figure}
\begin{center}
<<label=combine, fig = TRUE, echo = FALSE, results=hide>>=
source("src/intro-16-combine.R")
@
\end{center}
\caption{Combine low level graphic functions to generate high level graphic}
\label{fig:combine}
\end{figure}

\section{Advanced plottings}

\subsection{Draw part of the circos layout}
{\tt canvas.xlim} and {\tt canvas.ylim} in {\tt circos.par} is useful to draw only part of circle. In the example,
only sectors between $0^\circ$ to $90^\circ$ are plotted (figure \ref{fig:part}). First, four sectors
with the same width are initialized. Then only the first sector is drawn with points and lines. From figure \ref{fig:part},
we in fact created the whole circle, but only a quarter of the circle is in the canvas region. Codes are as follows. 

<<eval=FALSE, echo=TRUE>>=
library(circlize)
par(mar = c(1, 1, 1, 1))
circos.par("canvas.xlim" = c(0, 1), "canvas.ylim" = c(0, 1),
    "clock.wise" = FALSE, "gap.degree" = 0)
factors = letters[1:4]
circos.initialize(factors = factors, xlim = c(0, 1))
circos.trackPlotRegion(factors = factors, ylim = c(0, 1), bg.border = NA)
circos.updatePlotRegion(sector.index = "a", bg.border = "black")
x1 = runif(100)
y1 = runif(100)
circos.points(x1, y1, pch = 16, cex = 0.5)
circos.trackPlotRegion(factors = factors, ylim = c(0, 1), bg.border = NA)
circos.updatePlotRegion(sector.index = "a", bg.border = "black")
circos.lines(1:100/100, y1, pch = 16, cex = 0.5)
circos.clear()
@

\setkeys{Gin}{width=0.6\textwidth}
\begin{figure}
\begin{center}
<<label=figpart, fig = TRUE, echo = FALSE, height=8, width=4, results=hide>>=
source("src/intro-17-part.R")
@
\end{center}
\caption{Part of the circular layout}
\label{fig:part}
\end{figure}
\setkeys{Gin}{width=0.8\textwidth}

In the second situation, you don't need some sectors or cells but still you need to draw the whole circle.
Remember when you are creating new track with {\tt circos.trackPlotRegion} and set {\tt bg.col} and {\tt bg.border}
to {\tt NA}, it means create the new track and draw nothing. After that, you can use {\tt circos.updatePlotRegion} to update
these invisible cells of interest to add graphics on it (figure \ref{fig:part2}).

<<eval=FALSE, echo=TRUE>>=
library(circlize)
par(mar = c(1, 1, 1, 1))
factors = letters[1:4]
circos.initialize(factors = factors, xlim = c(0, 1))
circos.trackPlotRegion(factors = factors, ylim = c(0, 1), bg.col = NA, bg.border = NA)
circos.updatePlotRegion(sector.index = "a", bg.border = "black")
x1 = runif(100)
y1 = runif(100)
circos.points(x1, y1, pch = 16, cex = 0.5)

circos.trackPlotRegion(factors = factors, ylim = c(0, 1),bg.col = NA, bg.border = NA)
circos.updatePlotRegion(sector.index = "a", bg.border = "black")
x1 = runif(100)
y1 = runif(100)
circos.points(x1, y1, pch = 16, cex = 0.5)

circos.trackPlotRegion(factors = factors, ylim = c(0, 1))
circos.trackPlotRegion(factors = factors, ylim = c(0, 1))
circos.clear()
@

\begin{figure}
\begin{center}
<<label=figpart2, fig = TRUE, echo = FALSE, height=4, width=4, results=hide>>=
source("src/intro-18-part2.R")
@
\end{center}
\caption{Part of the circular layout, situation 2.}
\label{fig:part2}
\end{figure}


\subsection{Combine several parts of circular layouts}
Since circular layout by {\it circlize} is finally plotted in an ordinary R plotting system.
Two seperated circular layouts can be plotted together by some tricks. Here the key is 
{\tt par(new = TRUE)} which allows to draw a new figure on the previous canvas region.
{\bf Just remember the radius of the circos is always 1.}

The first example is to draw one outer circos plot and an inner circos plot (figure \ref{fig:nested}).

<<eval=FALSE, echo=TRUE>>=
library(circlize)
par(mar = c(1, 1, 1, 1))
factors = letters[1:4]
circos.initialize(factors = factors, xlim = c(0, 1))
circos.trackPlotRegion(ylim = c(0, 1), panel.fun = function(x, y) {
    circos.text(0.5, 0.5, "outer circos")
})
circos.clear()

par(new = TRUE)
circos.par("canvas.xlim" = c(-2, 2), "canvas.ylim" = c(-2, 2))
factors = letters[1:3]
circos.initialize(factors = factors, xlim = c(0, 1))
circos.trackPlotRegion(ylim = c(0, 1), panel.fun = function(x, y) {
    circos.text(0.5, 0.5, "inner circos")
})
circos.clear()
@


\setkeys{Gin}{width=\textwidth}
\begin{figure}
\begin{center}
<<label=fignested, fig = TRUE, echo = FALSE, height=6, width=6, results=hide>>=
source("src/intro-19-nested.R")
@
\end{center}
\caption{An outer and an inner circular layout}
\label{fig:nested}
\end{figure}
\setkeys{Gin}{width=0.8\textwidth}

The second example is drawing two seperated circular layouts in which every
circos plot only contains a half (figure \ref{fig:twoseperate}).

<<eval=FALSE, echo=TRUE>>=
library(circlize)
par(mar = c(1, 1, 1, 1))
factors = letters[1:4]
circos.par("canvas.xlim" = c(-1, 1.5), "canvas.ylim" = c(-1, 1.5), start.degree = -45)
circos.initialize(factors = factors, xlim = c(0, 1))
circos.trackPlotRegion(ylim = c(0, 1), bg.col = NA, bg.border = NA)
circos.updatePlotRegion(sector.index = "a")
circos.text(0.5, 0.5, "first one")
circos.updatePlotRegion(sector.index = "b")
circos.text(0.5, 0.5, "first one")

circos.clear()

par(new = TRUE)
circos.par("canvas.xlim" = c(-1.5, 1), "canvas.ylim" = c(-1.5, 1), start.degree = -45)
circos.initialize(factors = factors, xlim = c(0, 1))
circos.trackPlotRegion(ylim = c(0, 1), bg.col = NA, bg.border = NA)
circos.updatePlotRegion(sector.index = "d")
circos.text(0.5, 0.5, "second one")
circos.updatePlotRegion(sector.index = "c")
circos.text(0.5, 0.5, "second one")

circos.clear()
@

\setkeys{Gin}{width=\textwidth}
\begin{figure}
\begin{center}
<<label=figseperated, fig = TRUE, echo = FALSE, height=6, width=6, results=hide>>=
source("src/intro-20-seperated.R")
@
\end{center}
\caption{Two seperated circos layouts}
\label{fig:twoseperate}
\end{figure}
\setkeys{Gin}{width=0.8\textwidth}

The third example is to draw sectors with different radius (figure \ref{fig:difrad}). In fact,
it draws four circos graphs in which only one sector of each graphs is plotted. Note links
can not be drawn in these different sectors because links can only be drawn in one circos
plot. 

<<eval=FALSE, echo=TRUE>>=
library(circlize)
par(mar = c(1, 1, 1, 1))
factors = letters[1:4]
lim = c(1, 1.1, 1.2, 1.3)
for(i in 1:4) {
    circos.par("canvas.xlim" = c(-lim[i], lim[i]),
        "canvas.ylim" = c(-lim[i], lim[i]), "default.track.height" = 0.4)
    circos.initialize(factors = factors, xlim = c(0, 1))
    circos.trackPlotRegion(ylim = c(0, 1), bg.border = NA)
    circos.updatePlotRegion(sector.index = factors[i], bg.border = "black")
    circos.points(runif(10), runif(10), pch = 16)
    circos.clear()
    par(new = TRUE)
}
par(new = FALSE)
@

It is different from example in ``Draw part of the circular layout'' section. In that example,
cells both visible and invisible all belong to a same track and they are in a same circos plot, so they
should have same radius. But here, cells have different radius to the center of the circle and they
belong to different circos plot (although only part of each circos plot is visible).


\begin{figure}
\begin{center}
<<label=figdifrad, fig = TRUE, echo = FALSE, results=hide>>=
source("src/intro-21-diffradius.R")
@
\end{center}
\caption{Sectors with different radius}
\label{fig:difrad}
\end{figure}

\subsection{Draw outside and combine with canvas coordinate}
Sometimes it is very useful to draw something outside the plotting region of cell. (You can think it is
similar as {\tt par(xpd = NA)} setting.) The following is a simple
example to illustrate such circumstance (figure \ref{fig:outside}). The text is drawn outside the cell.

<<eval=FALSE, echo=TRUE>>=
library(circlize)
set.seed(12345)
par(mar = c(1, 1, 1, 1))
factors = letters[1:4]
circos.par("canvas.xlim" = c(-1.5, 1.5), "canvas.ylim" = c(-1.5, 1.5), "gap.degree" = 10)
circos.initialize(factors = factors, xlim = c(0, 1))
circos.trackPlotRegion(ylim = c(0, 1), panel.fun = function(x, y) {
    circos.points(1:20/20, 1:20/20)
})
circos.lines(c(1/20, 0.5), c(1/20, 3), sector.index = "d", straight = TRUE)
circos.text(0.5, 3, "mark", sector.index = "d", adj = c(0.5, 0))

circos.trackPlotRegion(ylim = c(0, 1), panel.fun = function(x, y) {
    circos.points(1:20/20, 1:20/20)
})
text(0, 0, "this is\nthe center", cex = 1.5)
legend("bottomleft", pch = 1, legend = "this is the legend")
circos.clear()
@

Since the final graphic is drawn in an ordinary canvas plotting region, we can add additional graphics through
the traditional way. It is useful to add some legends or marks on the figure. You can see how {\tt text} and {\tt legend} work in the example code.


\begin{figure}
\begin{center}
<<label=figoutside, fig = TRUE, echo = FALSE, results=hide>>=
source("src/intro-22-outside.R")
@
\end{center}
\caption{Draw outside the cell and combine with canvas coordinate}
\label{fig:outside}
\end{figure}

\subsection{Draw figures with {\tt layout}}
You can use {\tt layout} to arrange multiple figures together (also it is available from {\tt par(mfrow)}
or {\tt par(mfcol)}) (figure \ref{fig:layout}). 

<<eval=FALSE, echo=TRUE>>=
library(circlize)

set.seed(12345)
rand_color = function() {
    return(rgb(runif(1), runif(1), runif(1)))
}

layout(matrix(1:9, 3, 3))
for(i in 1:9) {
    factors = 1:8
    par(mar = c(0.5, 0.5, 0.5, 0.5))
    circos.par(cell.padding = c(0, 0, 0, 0))
    circos.initialize(factors, xlim = c(0, 1))
    circos.trackPlotRegion(ylim = c(0, 1), track.height = 0.05,
        bg.col = sapply(1:8, function(x) rand_color()), bg.border = NA)
    for(i in 1:20) {
        se = sample(1:8, 2)
        col = rand_color()
        col = paste(col, "40", sep = "")
        circos.link(se[1], runif(2), se[2], runif(2), col = col)
    }
    circos.clear()
}
@

\begin{figure}
\begin{center}
<<label=figlayout, fig = TRUE, echo = FALSE, results=hide>>=
source("src/intro-23-layout.R")
@
\end{center}
\caption{Draw multiple figures by {\tt layout}}
\label{fig:layout}
\end{figure}

\end{document}
